[{"content":"이산수학(Discrete mathematics)  불연속적인 숫자를 다루는 수학\n컴퓨터를 위한 수학, 참과 거짓으로 판단할 수 있으며 자료구조 또는 알고리즘의 베이스, 논리적 사고, 컴퓨팅 사고력 향상\n 1. 명제  참이나 거짓으로 진리를 구분할 수 있는 문장 명제는 0또는 1만을 가지는 컴퓨터 메모리처럼 항상 참과 거짓 중 하나의 값만을 가짐 여러 개의 명제를 조합할 수 있음  2. 연산자 명제를 다루기 위한 도구\n\r\n3. 명제의 역, 이, 대우  조건 명제에서 사용되는 역, 이, 대우는 하나의 명제를 변형하여 표현 증명하기 어려운 명제는 대우를 이용하여 증명할 수 있다 대우가 참인 경우 본 명제 또한 참이라는 특성을 가지고 있다  \r\n4. 진리표 \r\n5. 동치관계  동치란 논리적으로 일치한다는 의미 흔히 동치는 같은 의미를 가진 더 쉬운 명제를 발견하는 데 사용 동치법칙에는 다양한 종류가 존재  \r\n","date":"2021-07-13T00:00:00Z","image":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99/math_hu8d027683bf45a66bb5fe4bb6f0f36a3b_183689_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99/","title":"[CS]이산수학"},{"content":"타이타닉 데이터 분석 프로젝트 후기❓ 타이타닉 데이터분석 프로젝트를 진행하면서 느꼈던 궁금증 해결하기!!!\n1. NULL Data 채우는 다양한 방식 데이터 분석 초기 과정에서 가장 중요한 일 중 하나가 바로 결측치/결측값 처리이다.\n여기에 따라 모델 생성과 결과 도출에 이르기까지 큰 영향을 끼치기 때문이다.\n  첫번째 방법, 제거하기\n  목록삭제(Listwise)\n결측치가 존재하는 전체 행을 삭제\n\r\n  단일값 삭제(Pairwise)\n손실된 관측치 자체만 삭제\n\r\n    두번째 방법, 채우기\n  평균화 기법(Popular Averaging)\n가장 널리 사용되는 기술로, 그룹의 평균값을 결측값에 채워준다.\n결측치를 빠르게 채울 수 있는 장점이 있지만, 결측치들이 동일한 값도 가질 수 있기 때문에 데이터셋의 변동을 인위적으로 줄여줘야 한다.\n\r\n  예측 기법(Predictive)\n결측치들의 특성이 무작위로 완전히 관찰되지 않는다고 가정하고 예측모델을 사용하여 결측값을 대치할 예측값을 생성\n회귀 분석 기술을 활용하거나 SVM과 같은 머신러닝 등의 데이터마이닝 방법을 사용\n     2. Feature별 상관관계, Heatmap 해석하기 Heatmap이란? 열을 의미하는 heat와 지도를 뜻하는 map을 합친 단어로 데이터들의 배열을 색상으로 표현\n여러 카테고리 값에 대한 값 변화를 한눈에 알기 쉽다는 장점이 있다.\n\r\n위의 데이터는 월별 비행기 이용 승객수이다. 빨간색이 짙을수록 승객수가 적음을 의미하고 빨간색이 얕아질수록 승객수가 높음을 의미한다.\n데이터 형태가 테이블 형태일때보다 히트맵으로 나타내면 언제 승객이 많은지, 승객수 변화가 어떠한지 쉽게 알 수 있다.\n 3. Label Encoding VS One-Hot Encoding 머신러닝을 위한 대표적인 인코딩 방식으로 Label과 One-Hot이 존재한다.\n  레이블 인코딩은 간단하게 문자열 값을 숫자형 카테고리 값으로 변환한다.\n그러나, 일괄적인 숫자값으로의 변환은 예측능력을 떨어트리는 원인이 될 수 있다.\n숫자에 따라 각 카테고리들의 가중치 차이가 발생할 수 있기 때문으로 선형회귀와 같은 ML알고리즘에서는 맞지 않는다.\n  원-핫 인코딩은 레이블 인코딩의 문제점을 해결하기 위한 인코딩 방식으로\nfeature값의 유형에 따라 새로운 feature를 추가하고 고유 값에 해당하는 칼럼에만 1을 표시하는 방식이다.\n\r\n위의 사진은 가전제품 feature를 원-핫 인코딩을 걸친 것이다.\n주의할 점이있다면 원-핫 인코딩하기 전에 모든 문자열 값이 숫자형 값으로 변환돼야 하며, 입력값으로 2차원 데이터가 필요하다는 것이다.\n  ","date":"2021-07-10T00:00:00Z","image":"https://ssabum.github.io/content/%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A6%AC%EB%B7%B0/end_hu771523524522bf8edc036416ae7f1a7b_21048_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A6%AC%EB%B7%B0/","title":"타이타닉 프로젝트 리뷰"},{"content":"타이타닉 데이터 분석 🚢  본격적으로 데이터분석에 드러가기에 앞서 튜토리얼을 진행해보려한다.\n코딩을 처음 배울때 Hello World를 출력하는 것 처럼 데이터분석의 시작은 타이타닉 데이터이다!!\n Kaggle과 Colab 연동 Google Colab 환경에서 프로젝트를 진행했는데 Kaggle의 data set을 가져오기 위해 하나하나 다운받을 필요없이 API를 이용해 불러올 수 있습니다!\n# kaggle과 colab 연동 !pip install kaggle # kaggle에서 api kaggle.json을 받아서 전송 from google.colab import files files.upload() !mkdir -p ~/.kaggle !cp kaggle.json ~/.kaggle/ !chmod 600 ~/.kaggle/kaggle.json # API로 data set download !kaggle competitions download -c 2019-1st-ml-month-with-kakr # 압축해제 !unzip -q /content/2019-1st-ml-month-with-kakr 왜 하필이면 타이타닉?? 데이터 분석 전체 프로세스를 빠르게 경험할 수 있으며, 접근하기 좋은 Binary Classification 문제이기 때문에\n진행 프로세스  데이터셋 확인   데이터를 수집하고 전처리  탐색적 데이터 분석(EDA)   여러 특성들을 분석하고 상관관계를 확인 시각화를 통해 insight 도출  특성공학(Feature Engineering)   모델의 성능을 높이기 위해 특성을 엔지니어링  모델 개발 및 학습   sklearn, keras 등을 이용해 모델을 제작  모델 예측 및 평가    훈련 데이터를 가지고 모델을 학습시키고, 테스트 데이터를 가지고 예측합니다.\n   1. 데이터셋 확인 # 데이터셋 확인 import os import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import keras import sklearn # seaborn 셋팅 =\u0026gt; matplotlib을 기반으로 다양한 색상 테마와 통계용 기능을 추가한 시각화 패키지 plt.style.use(\u0026#39;seaborn\u0026#39;) sns.set(font_scale=2.5) import missingno as msno import warnings # 경고 메시지 생략 warnings.filterwarnings(\u0026#39;ignore\u0026#39;) %matplotlib inline df_train = pd.read_csv(\u0026#39;train.csv\u0026#39;) df_test = pd.read_csv(\u0026#39;test.csv\u0026#39;) df_submit = pd.read_csv(\u0026#39;sample_submission.csv\u0026#39;) df_train.head() \r\n데이터 Feature 설명  survival - 생존유무 =\u0026gt; target 값 (0=사망, 1=생존) pclass - 티켓클래스 sex - 성별 age - 나이 sibsp - 함께 탑승한 형제자매, 배우자 수 총합 parch - 함꺼 탑승한 부모, 자녀 수 총합 ticket - 티켓 넘버 fare - 탑승 요금 cabin - 객실 넘버 bembarked - 탑승 항구  # 결측치 확인 =\u0026gt; train set과 test set에 비슷하게 age에 20% cabin에 80%의 결측지 발견 df_train.isnull().sum() / df_train.shape[0] \r\nTarget Label 확인 target label이 어떤 distribution을 가지고 있는지 확인 필요 binary classification에서 분포가 어떠냐에 따라 모델의 평가방법이 달라지기 때문에\nf, ax = plt.subplots(1, 2, figsize=(18, 8)) # 파이그래프 df_train[\u0026#39;Survived\u0026#39;].value_counts().plot.pie(explode=[0, 0.1], autopct=\u0026#39;%1.1f%%\u0026#39;, ax=ax[0], shadow=True) ax[0].set_title(\u0026#39;Pie plot - Survived\u0026#39;) ax[0].set_ylabel(\u0026#39;\u0026#39;) # 항목별 개수를 카운트 sns.countplot(\u0026#39;Survived\u0026#39;, data=df_train, ax=ax[1]) ax[1].set_title(\u0026#39;Count plot - Survived\u0026#39;) plt.show() # target label의 분포가 제법 균일하므로 binary classification에 적합 \r\n파이그래프 속성  plt.pie(slice, labels=activities, startangle=90, shadow=True, explode=(0, 0, 0.1, 0), autopct='%1.1f%%')\n   slice: 파이 조각의 데이터\n  labels: 파이 조각의 라벨\n  startangle: 그려지는 파이 조각 시작 위치\n  shadow: 파이 차트의 그림자 효과 유무\n  explode: 파이 조각이 돌출되는 크기\n  autopct: 파이 조각의 전체 대비 백분율\n   2. 탐색적 데이터 분석(Exploratory Data Analysys) Feature별로 데이터 분석 Insight 도출해보자\n1. Pclass  Pclass는 서수형 데이터입니다. Pclass,Survived 를 가져온 후, pclass 로 묶으면 각 pclass 마다 0, 1 이 count가 되는데, 이를 평균내면 각 pclass 별 생존률이 추출  # 생존률 df_train[[\u0026#39;Pclass\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;Pclass\u0026#39;], as_index=True).mean() \r\n# 막대그래프 시각화 df_train[[\u0026#39;Pclass\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;Pclass\u0026#39;], as_index=True).mean().plot.bar() # 생존률에 Pclass가 큰 영향을 미친다고 생각할 수 있다. # 따라서 모델 생성시 해당 feature 사용이 좋을 것이라 판단 \r\n2. Sex f, ax = plt.subplots(1, 2, figsize=(18, 8)) df_train[[\u0026#39;Sex\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;Sex\u0026#39;], as_index=True).mean().plot.bar(ax=ax[0]) ax[0].set_title(\u0026#39;Survived vs Sex\u0026#39;) sns.countplot(\u0026#39;Sex\u0026#39;, hue=\u0026#39;Survived\u0026#39;, data=df_train, ax=ax[1]) ax[1].set_title(\u0026#39;Sex: Survived vs Dead\u0026#39;) plt.show() # 남성보다 여성의 생존확률이 높습니다. # Pclass와 마찬가지로, Sex도 예측 모델에 쓰일 중요 featured임을 알 수 있다. \r\n3. Both Sex and Pclass # factor형의 변수의 시각화를 할 때 유용한 시각화 sns.factorplot(\u0026#39;Pclass\u0026#39;, \u0026#39;Survived\u0026#39;, hue=\u0026#39;Sex\u0026#39;, data=df_train, size=6, aspect=1.5) # 모든 클래스에서 여성의 생존률이 남성보다 높다. \r\n4. Age # 막대그래프는 어떤 분포로 퍼져있는지 확인할 수 없다. 그래서 분포를 확인할 때는 히스토그램을 사용 # but, 히스토그램은 구간을 어떻게 설정하냐에 따라 결과물이 크게 달라진다. # 그 대안으로 분포를 곡선화 시켜주는 커널밀도추정(KDE)을 많이 사용 fig, ax = plt.subplots(1, 1, figsize=(9, 5)) sns.kdeplot(df_train[df_train[\u0026#39;Survived\u0026#39;] == 1][\u0026#39;Age\u0026#39;], ax=ax) sns.kdeplot(df_train[df_train[\u0026#39;Survived\u0026#39;] == 0][\u0026#39;Age\u0026#39;], ax=ax) plt.legend([\u0026#39;Survived == 1\u0026#39;, \u0026#39;Survived == 0\u0026#39;]) plt.show() # 생존 KDE와 사망 KDE를 비교했을때 어린나이 구간에서 생존률이 상대적으로 높음을 알 수 있다. \r\ncummulate_survival_ratio = [] for i in range(1, 80): cummulate_survival_ratio.append(df_train[df_train[\u0026#39;Age\u0026#39;] \u0026lt; i][\u0026#39;Survived\u0026#39;].sum() / len(df_train[df_train[\u0026#39;Age\u0026#39;] \u0026lt; i][\u0026#39;Survived\u0026#39;])) plt.figure(figsize=(7, 7)) plt.plot(cummulate_survival_ratio) plt.title(\u0026#39;Survival rate change depending on range of Age\u0026#39;, y=1.02) plt.ylabel(\u0026#39;Survival rate\u0026#39;) plt.xlabel(\u0026#39;Range of Age(0~x)\u0026#39;) plt.show() # 나이가 어릴수록 생존률이 확실히 증가하는 것을 확인 가능 # Age도 중요 feature임을 확인할 수 있다. \r\n5. Embarked f, ax = plt.subplots(1, 1, figsize=(7, 7)) df_train[[\u0026#39;Embarked\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;Embarked\u0026#39;], as_index=True).mean().sort_values(by=\u0026#39;Survived\u0026#39;, ascending=False).plot.bar(ax=ax) # 탑승항구 별 생존률의 차이가 크진 않다. \r\n# 다른 feature와의 상관관계 f,ax=plt.subplots(2, 2, figsize=(20,15)) sns.countplot(\u0026#39;Embarked\u0026#39;, data=df_train, ax=ax[0,0]) ax[0,0].set_title(\u0026#39;(1) No. Of Passengers Boarded\u0026#39;) sns.countplot(\u0026#39;Embarked\u0026#39;, hue=\u0026#39;Sex\u0026#39;, data=df_train, ax=ax[0,1]) ax[0,1].set_title(\u0026#39;(2) Male-Female Split for Embarked\u0026#39;) sns.countplot(\u0026#39;Embarked\u0026#39;, hue=\u0026#39;Survived\u0026#39;, data=df_train, ax=ax[1,0]) ax[1,0].set_title(\u0026#39;(3) Embarked vs Survived\u0026#39;) sns.countplot(\u0026#39;Embarked\u0026#39;, hue=\u0026#39;Pclass\u0026#39;, data=df_train, ax=ax[1,1]) ax[1,1].set_title(\u0026#39;(4) Embarked vs Pclass\u0026#39;) plt.subplots_adjust(wspace=0.2, hspace=0.5) plt.show() \r\n Figure(1) - 전체적으로 봤을 때, S 에서 가장 많은 사람이 탑승했습니다. Figure(2) - C와 Q 는 남녀의 비율이 비슷하고, S는 남자가 더 많습니다. Figure(3) - 생존확률이 S 경우 많이 낮은 걸 볼 수 있습니다. (이전 그래프에서 봤었습니다) Figure(4) - Class 로 split 해서 보니, C가 생존확률이 높은건 클래스가 높은 사람이 많이 타서 그렇습니다. S는 3rd class 가 많아서 생존확률이 낮게 나옵니다.  6. Family(Sibsp + Parch) # Sibsp와 Parch를 합치면 함께 탑승한 가족의 수가 되므로 새로운 Feature 생성 df_train[\u0026#39;FamilySize\u0026#39;] = df_train[\u0026#39;SibSp\u0026#39;] + df_train[\u0026#39;Parch\u0026#39;] + 1 # 자신을 포함해야하니 1을 더합니다 df_test[\u0026#39;FamilySize\u0026#39;] = df_test[\u0026#39;SibSp\u0026#39;] + df_test[\u0026#39;Parch\u0026#39;] + 1 # 자신을 포함해야하니 1을 더합니다 f,ax=plt.subplots(1, 3, figsize=(40,10)) sns.countplot(\u0026#39;FamilySize\u0026#39;, data=df_train, ax=ax[0]) ax[0].set_title(\u0026#39;(1) No. Of Passengers Boarded\u0026#39;, y=1.02) sns.countplot(\u0026#39;FamilySize\u0026#39;, hue=\u0026#39;Survived\u0026#39;, data=df_train, ax=ax[1]) ax[1].set_title(\u0026#39;(2) Survived countplot depending on FamilySize\u0026#39;, y=1.02) df_train[[\u0026#39;FamilySize\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;FamilySize\u0026#39;], as_index=True).mean().sort_values(by=\u0026#39;Survived\u0026#39;, ascending=False).plot.bar(ax=ax[2]) ax[2].set_title(\u0026#39;(3) Survived rate depending on FamilySize\u0026#39;, y=1.02) plt.subplots_adjust(wspace=0.2, hspace=0.5) plt.show() \r\n Figure (1) - 가족크기가 1~11까지 있음을 볼 수 있습니다. 대부분 1명이고 그 다음으로 2, 3, 4명입니다. Figure (2), (3) - 가족 크기에 따른 생존비교입니다. 가족이 4명인 경우가 가장 생존확률이 높습니다, 가족수가 많아질수록, (5, 6, 7, 8, 11) 생존확률이 낮아지네요. 가족수가 너무 작아도(1), 너무 커도(5, 6, 8, 11) 생존 확률이 작네요. 3~4명 선에서 생존확률이 높은 걸 확인할 수 있습니다.  7. Fare # 탑승요금은 연속적인 데이터이므로 히스토그램 시각화 fig, ax = plt.subplots(1, 1, figsize=(8, 8)) g = sns.distplot(df_train[\u0026#39;Fare\u0026#39;], color=\u0026#39;b\u0026#39;, label=\u0026#39;Skewness : {:.2f}\u0026#39;.format(df_train[\u0026#39;Fare\u0026#39;].skew()), ax=ax) g = g.legend(loc=\u0026#39;best\u0026#39;) # 특이하기도 train set 말고 test set에 Fare 피쳐에 널 값이 하나 존재하는 것을 확인할 수 있었습니다. # 그래서 평균 값으로 해당 널값을 넣어줍니다. df_test.loc[df_test.Fare.isnull(), \u0026#39;Fare\u0026#39;] = df_test[\u0026#39;Fare\u0026#39;].mean() # testset 에 있는 nan value 를 평균값으로 치환합니다. # log를 취해 보기 편하게 변환 df_train[\u0026#39;Fare\u0026#39;] = df_train[\u0026#39;Fare\u0026#39;].map(lambda i: np.log(i) if i \u0026gt; 0 else 0) df_test[\u0026#39;Fare\u0026#39;] = df_test[\u0026#39;Fare\u0026#39;].map(lambda i: np.log(i) if i \u0026gt; 0 else 0) fig, ax = plt.subplots(1, 1, figsize=(8, 8)) g = sns.distplot(df_train[\u0026#39;Fare\u0026#39;], color=\u0026#39;b\u0026#39;, label=\u0026#39;Skewness : {:.2f}\u0026#39;.format(df_train[\u0026#39;Fare\u0026#39;].skew()), ax=ax) g = g.legend(loc=\u0026#39;best\u0026#39;) \r\n8. Cabin NaN이 대략 80% 이므로, 생존에 영향을 미칠 중요한 정보를 얻어내기가 쉽지는 않습니다.\n9. Ticket NaN은 없지만 이 데이터로 유효한 결과를 뽑아내기위해선 아이디어가 필요\n 3. 특성공학(Feature Engineering) Fill Null null data를 어떻게 채우느냐에 따라 모델의 성능이 좌지우지되므로 중요, train 뿐만 아니라 test도 똑같이 적용\n1. Age df_train[\u0026#39;Initial\u0026#39;]= df_train.Name.str.extract(\u0026#39;([A-Za-z]+)\\.\u0026#39;) #lets extract the Salutations df_test[\u0026#39;Initial\u0026#39;]= df_test.Name.str.extract(\u0026#39;([A-Za-z]+)\\.\u0026#39;) #lets extract the Salutations # Initial과 Sex간의 count pd.crosstab(df_train[\u0026#39;Initial\u0026#39;], df_train[\u0026#39;Sex\u0026#39;]).T.style.background_gradient(cmap=\u0026#39;summer_r\u0026#39;) #Checking the Initials with the Sex df_train[\u0026#39;Initial\u0026#39;].replace([\u0026#39;Mlle\u0026#39;,\u0026#39;Mme\u0026#39;,\u0026#39;Ms\u0026#39;,\u0026#39;Dr\u0026#39;,\u0026#39;Major\u0026#39;,\u0026#39;Lady\u0026#39;,\u0026#39;Countess\u0026#39;,\u0026#39;Jonkheer\u0026#39;,\u0026#39;Col\u0026#39;,\u0026#39;Rev\u0026#39;,\u0026#39;Capt\u0026#39;,\u0026#39;Sir\u0026#39;,\u0026#39;Don\u0026#39;, \u0026#39;Dona\u0026#39;], [\u0026#39;Miss\u0026#39;,\u0026#39;Miss\u0026#39;,\u0026#39;Miss\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mrs\u0026#39;,\u0026#39;Mrs\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;, \u0026#39;Mr\u0026#39;],inplace=True) df_test[\u0026#39;Initial\u0026#39;].replace([\u0026#39;Mlle\u0026#39;,\u0026#39;Mme\u0026#39;,\u0026#39;Ms\u0026#39;,\u0026#39;Dr\u0026#39;,\u0026#39;Major\u0026#39;,\u0026#39;Lady\u0026#39;,\u0026#39;Countess\u0026#39;,\u0026#39;Jonkheer\u0026#39;,\u0026#39;Col\u0026#39;,\u0026#39;Rev\u0026#39;,\u0026#39;Capt\u0026#39;,\u0026#39;Sir\u0026#39;,\u0026#39;Don\u0026#39;, \u0026#39;Dona\u0026#39;], [\u0026#39;Miss\u0026#39;,\u0026#39;Miss\u0026#39;,\u0026#39;Miss\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mrs\u0026#39;,\u0026#39;Mrs\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;, \u0026#39;Mr\u0026#39;],inplace=True) # train 에서 얻은 statistics 를 기반으로 null data 채우기 df_train.groupby(\u0026#39;Initial\u0026#39;).mean() # 각 initial 그룹별 Age 평균 값을 사용해서 채우기 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Mr\u0026#39;),\u0026#39;Age\u0026#39;] = 33 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Mrs\u0026#39;),\u0026#39;Age\u0026#39;] = 36 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Master\u0026#39;),\u0026#39;Age\u0026#39;] = 5 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Miss\u0026#39;),\u0026#39;Age\u0026#39;] = 22 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Other\u0026#39;),\u0026#39;Age\u0026#39;] = 46 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Mr\u0026#39;),\u0026#39;Age\u0026#39;] = 33 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Mrs\u0026#39;),\u0026#39;Age\u0026#39;] = 36 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Master\u0026#39;),\u0026#39;Age\u0026#39;] = 5 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Miss\u0026#39;),\u0026#39;Age\u0026#39;] = 22 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Other\u0026#39;),\u0026#39;Age\u0026#39;] = 46 2. Embarked # S에서 가장 많이 탔으므로 S로 채우기 df_train[\u0026#39;Embarked\u0026#39;].fillna(\u0026#39;S\u0026#39;, inplace=True) df_train.isnull().sum()[df_train.isnull().sum() \u0026gt; 0] Change Age Age는 continuous feature이지만 그룹화하여 카테코리화 시켜줄 수 있다. continous를 categorical로 바꾸면 impormation loss가 생길 수 있으므로 주의\ndef category_age(x): if x \u0026lt; 10: return 0 elif x \u0026lt; 20: return 1 elif x \u0026lt; 30: return 2 elif x \u0026lt; 40: return 3 elif x \u0026lt; 50: return 4 elif x \u0026lt; 60: return 5 elif x \u0026lt; 70: return 6 else: return 7 df_train[\u0026#39;Age_cat\u0026#39;] = df_train[\u0026#39;Age\u0026#39;].apply(category_age) df_test[\u0026#39;Age_cat\u0026#39;] = df_test[\u0026#39;Age\u0026#39;].apply(category_age) \r\nChange Initial, Embarked and Sex 컴퓨터가 인식할 수 있도록 수치화\ndf_train[\u0026#39;Initial\u0026#39;] = df_train[\u0026#39;Initial\u0026#39;].map({\u0026#39;Master\u0026#39;: 0, \u0026#39;Miss\u0026#39;: 1, \u0026#39;Mr\u0026#39;: 2, \u0026#39;Mrs\u0026#39;: 3, \u0026#39;Other\u0026#39;: 4}) df_test[\u0026#39;Initial\u0026#39;] = df_test[\u0026#39;Initial\u0026#39;].map({\u0026#39;Master\u0026#39;: 0, \u0026#39;Miss\u0026#39;: 1, \u0026#39;Mr\u0026#39;: 2, \u0026#39;Mrs\u0026#39;: 3, \u0026#39;Other\u0026#39;: 4}) df_train[\u0026#39;Embarked\u0026#39;] = df_train[\u0026#39;Embarked\u0026#39;].map({\u0026#39;C\u0026#39;: 0, \u0026#39;Q\u0026#39;: 1, \u0026#39;S\u0026#39;: 2}) df_test[\u0026#39;Embarked\u0026#39;] = df_test[\u0026#39;Embarked\u0026#39;].map({\u0026#39;C\u0026#39;: 0, \u0026#39;Q\u0026#39;: 1, \u0026#39;S\u0026#39;: 2}) df_train[\u0026#39;Sex\u0026#39;] = df_train[\u0026#39;Sex\u0026#39;].map({\u0026#39;female\u0026#39;: 0, \u0026#39;male\u0026#39;: 1}) df_test[\u0026#39;Sex\u0026#39;] = df_test[\u0026#39;Sex\u0026#39;].map({\u0026#39;female\u0026#39;: 0, \u0026#39;male\u0026#39;: 1}) # 각 feature별 상관관계 시각화 heatmap_data = df_train[[\u0026#39;Survived\u0026#39;, \u0026#39;Pclass\u0026#39;, \u0026#39;Sex\u0026#39;, \u0026#39;Fare\u0026#39;, \u0026#39;Embarked\u0026#39;, \u0026#39;FamilySize\u0026#39;, \u0026#39;Initial\u0026#39;, \u0026#39;Age_cat\u0026#39;, \u0026#39;Age\u0026#39;]] colormap = plt.cm.RdBu plt.figure(figsize=(14, 12)) plt.title(\u0026#39;Pearson Correlation of Features\u0026#39;, y=1.05, size=15) sns.heatmap(heatmap_data.astype(float).corr(), linewidths=0.1, vmax=1.0, square=True, cmap=colormap, linecolor=\u0026#39;white\u0026#39;, annot=True, annot_kws={\u0026#34;size\u0026#34;: 16}) del heatmap_data \r\n Sex 와 Pclass 가 Survived 에 상관관계가 어느 정도 있음을 볼 수 있습니다. 생각보다 fare 와 Embarked 도 상관관계가 있음을 볼 수 있습니다. 강한 상관관계를 가지는 feature들이 없다. 따라서 모델을 학습시킬 때, 불필요한 feature 가 없다.  데이터전처리(Data Preprocessing) 모델의 성능을 높이기 위해 데이터 전처리 과정\nOne-hot encoding on Initiall and Embarked One-hot encoding을 통해 각 클래스간 연관성을 동이하게 생성category가 많을 경우 column이 너무 많이 생성되어 차원의 저주 발생 주의\ndf_train = pd.get_dummies(df_train, columns=[\u0026#39;Initial\u0026#39;], prefix=\u0026#39;Initial\u0026#39;) df_test = pd.get_dummies(df_test, columns=[\u0026#39;Initial\u0026#39;], prefix=\u0026#39;Initial\u0026#39;) \r\ndf_train = pd.get_dummies(df_train, columns=[\u0026#39;Embarked\u0026#39;], prefix=\u0026#39;Embarked\u0026#39;) df_test = pd.get_dummies(df_test, columns=[\u0026#39;Embarked\u0026#39;], prefix=\u0026#39;Embarked\u0026#39;) Drop Columns 필요없는 피쳐 제거\ndf_train.drop([\u0026#39;PassengerId\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;SibSp\u0026#39;, \u0026#39;Parch\u0026#39;, \u0026#39;Ticket\u0026#39;, \u0026#39;Cabin\u0026#39;], axis=1, inplace=True) df_test.drop([\u0026#39;PassengerId\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;SibSp\u0026#39;, \u0026#39;Parch\u0026#39;, \u0026#39;Ticket\u0026#39;, \u0026#39;Cabin\u0026#39;], axis=1, inplace=True) 4. 모델 개발 및 학습 Sklearn은 머신러닝에 관련된 모든 작업들이 손쉬운 인터페이스로 구현되어 있다. 현재 우리는 train set의 survived를 제외한 input을 가지고 모델을 최적화 시켜 탑승객의 생존유무를 판단하는 모델을 생성 그 후 test set을 input으로 주어서 탑승객의 생존유무를 예측\n#importing all the required ML packages from sklearn.ensemble import RandomForestClassifier # 유명한 randomforestclassfier 입니다.  from sklearn import metrics # 모델의 평가를 위해서 씁니다 from sklearn.model_selection import train_test_split # traning set을 쉽게 나눠주는 함수입니다. ### Preparation - Split dataset into train, valid, test set ​```python X_train = df_train.drop(\u0026#39;Survived\u0026#39;, axis=1).values target_label = df_train[\u0026#39;Survived\u0026#39;].values X_test = df_test.values X_tr, X_vld, y_tr, y_vld = train_test_split(X_train, target_label, test_size=0.2, random_state=2018) Model generation and prediction Random Forest 여러 알고리즘 중 랜덤포레스트를 사용 랜덤포레스트는 결정트리기반 모델로 여러 결정 트리들을 앙상블한 모델\nmodel = RandomForestClassifier() # 생성 model.fit(X_tr, y_tr) # 학습 prediction = model.predict(X_vld) # 예측 print(\u0026#39;총 {}명 중 {:.2f}% 정확도로 생존을 맞춤\u0026#39;.format(y_vld.shape[0], 100 * metrics.accuracy_score(prediction, y_vld))) # 총 179명 중 81.56% 정확도로 생존을 맞춤 # 학습된 모델은 feature importance를 가지게 되는데, # 이는 어떤 feature가 결과에 영향을 많이 미쳤는지 확인할 수 있다. from pandas import Series feature_importance = model.feature_importances_ Series_feat_imp = Series(feature_importance, index=df_test.columns) plt.figure(figsize=(8, 8)) Series_feat_imp.sort_values(ascending=True).plot.barh() plt.xlabel(\u0026#39;Feature importance\u0026#39;) plt.ylabel(\u0026#39;Feature\u0026#39;) plt.show() \r\nNN모델(Neural Network model) - 딥러닝 모델 from keras.models import Sequential from keras.layers.core import Dense, Dropout from keras.optimizers import Adam, SGD nn_model = Sequential() nn_model.add(Dense(32,activation=\u0026#39;relu\u0026#39;,input_shape=(14,))) nn_model.add(Dropout(0.2)) nn_model.add(Dense(64,activation=\u0026#39;relu\u0026#39;)) nn_model.add(Dropout(0.2)) nn_model.add(Dense(32,activation=\u0026#39;relu\u0026#39;)) nn_model.add(Dropout(0.2)) nn_model.add(Dense(1,activation=\u0026#39;sigmoid\u0026#39;)) Loss = \u0026#39;binary_crossentropy\u0026#39; nn_model.compile(loss=Loss,optimizer=Adam(),metrics=[\u0026#39;accuracy\u0026#39;]) history = nn_model.fit(X_tr,y_tr, batch_size=64, epochs=500, validation_data=(X_vld, y_vld), verbose=1) hists = [history] hist_df = pd.concat([pd.DataFrame(hist.history) for hist in hists], sort=True) hist_df.index = np.arange(1, len(hist_df)+1) fig, axs = plt.subplots(nrows=2, sharex=True, figsize=(16, 10)) axs[0].plot(hist_df.val_accuracy, lw=5, label=\u0026#39;Validation Accuracy\u0026#39;) axs[0].plot(hist_df.accuracy, lw=5, label=\u0026#39;Training Accuracy\u0026#39;) axs[0].set_ylabel(\u0026#39;Accuracy\u0026#39;) axs[0].set_xlabel(\u0026#39;Epoch\u0026#39;) axs[0].grid() axs[0].legend(loc=0) axs[1].plot(hist_df.val_loss, lw=5, label=\u0026#39;Validation MLogLoss\u0026#39;) axs[1].plot(hist_df.loss, lw=5, label=\u0026#39;Training MLogLoss\u0026#39;) axs[1].set_ylabel(\u0026#39;MLogLoss\u0026#39;) axs[1].set_xlabel(\u0026#39;Epoch\u0026#39;) axs[1].grid() axs[1].legend(loc=0) fig.savefig(\u0026#39;hist.png\u0026#39;, dpi=300) plt.show(); \r\n5. 모델 예측 및 평가 랜덤포레스트 submission = pd.read_csv(\u0026#39;sample_submission.csv\u0026#39;) prediction = model.predict(X_test) submission[\u0026#39;Survived\u0026#39;] = prediction submission.to_csv(\u0026#39;my_first_submission.csv\u0026#39;, index=False) # 정확도 스코어: 0.75598 NN모델 submission = pd.read_csv(\u0026#39;sample_submission.csv\u0026#39;) prediction = nn_model.predict(X_test) prediction = prediction \u0026gt; 0.5 prediction = prediction.astype(np.int) prediction = prediction.T[0] submission[\u0026#39;Survived\u0026#39;] = prediction submission.to_csv(\u0026#39;my_nn_submission.csv\u0026#39;, index=False) # 정확도 사코어: 0.77990  Google Colab환경에서 진행하고 markdown으로 포스팅하는 거라 설명이 부족한 점은 양해바랍니다;;💦💦\n예전에 잠깐 해보았던 데이터분석이지만 오랜만에 다시한번 해보니 감회가 새로웠고 진행하는 과정에서 느낀 궁금점들은 따로 정리하여 포스팅하도록 하겠습니당!!!\n원본소스코드.ipynb 👉 https://github.com/ssabum/note/blob/master/data_analysis/titanic.ipynb\n","date":"2021-07-09T00:00:00Z","image":"https://ssabum.github.io/content/data-analysis-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89/titanic_hu283fdd82a3189859b359fc7b8f11d672_184666_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/data-analysis-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89/","title":"Data analysis 타이타닉"},{"content":"내 근황\u0026hellip; 그동안 블로그 활동을 하지 못했는데\u0026hellip;마음이 뜬 것도 있고, ssafy 1학기 프로젝트에 정신 팔린 것도 있고\u0026hellip;\n이제 다시 맘먹고 열심히 할 생각이다!!\n생각보다 난 한게 아무것도 없었고 앞으로 할 수 있는게 많다는 뜻이니!!\n그래도 그동안 ssafy 1학기를 잘 마무리하고, 정보처리기사와 sqld 자격정을 취득했다.\n이제는 ssafy 2학기 프로젝트를 진행하면서 본격적으로 내 실력을 키우기 위한 공부를 시작해야겠지!\n","date":"2021-07-09T00:00:00Z","image":"https://ssabum.github.io/content/%EA%B7%BC%ED%99%A9%EC%9D%B4%EC%9A%94/todo_hub8956bba192ccf8149451449a4cced01_62392_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/%EA%B7%BC%ED%99%A9%EC%9D%B4%EC%9A%94/","title":"근황이요"},{"content":"1780번 종이의 개수 문제 보러가기\n🅰 코드 import sys N = int(sys.stdin.readline()) data = [] for _ in range(N): data.append(list(map(int, sys.stdin.readline().split()))) result = {\u0026#34;-1\u0026#34;: 0, \u0026#34;0\u0026#34;: 0, \u0026#34;1\u0026#34;: 0} # 체크 함수 def check(row, col, N): value = data[row][col] for i in range(N): for j in range(N): if value != data[row + i][col + j]: # 9분할 check(row, col, N // 3) check(row, col + N // 3, N // 3) check(row, col + N * 2 // 3, N // 3) check(row + N // 3, col, N // 3) check(row + N // 3, col + N // 3, N // 3) check(row + N // 3, col + N * 2 // 3, N // 3) check(row + N * 2 // 3, col, N // 3) check(row + N * 2 // 3, col + N // 3, N // 3) check(row + N * 2 // 3, col + N * 2 // 3, N // 3) return result[str(value)] += 1 check(0, 0, N) # 결과 출력 print(result[\u0026#34;-1\u0026#34;]) print(result[\u0026#34;0\u0026#34;]) print(result[\u0026#34;1\u0026#34;]) ✅ 후기  전에 풀어보았던 색종이 문제와 유사했다. 그때는 4분할 이었지만 지금은 9분할이라는 차이가 있을뿐?.. 그림으로 좌표를 찍어내면 다음과 같다.  \r\n 단지 좀 귀찮았던 것은 분할하는 과정을 계속 반복해줬는데 이걸 한번에 처리할 방법이 없는지 고민이 되었다\u0026hellip;💦  ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1780%EB%B2%88-%EC%A2%85%EC%9D%B4%EC%9D%98-%EA%B0%9C%EC%88%98/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1780%EB%B2%88-%EC%A2%85%EC%9D%B4%EC%9D%98-%EA%B0%9C%EC%88%98/","title":"백준 1780번 종이의 개수"},{"content":"1927번 최소 힙 문제 보러가기\n🅰 코드 import heapq import sys N = int(input()) heap = [] for _ in range(N): num = int(sys.stdin.readline()) if num == 0: if heap: print(heapq.heappop(heap)) else: print(0) else: heapq.heappush(heap, num) ✅ 후기   heap을 다루는 문제로 숫자가 들어왔을 때는 heappush로 출력하고 0이 들어오면 heappop을 한 뒤 print를 하도록 구상하였다.\n  이 문제의 중점은 시간단축을 위해 sys.stdin.readline()과 heapq을 사용하는 것이다. 전에도 종종 언급했었지만 다시한번 정리하자면 인풋받는 메소드의 속도차이는 다음과 같다.\nsys.stdin.readline \u0026lt; raw_input() \u0026lt; input() # sys.sydin.readline: 한줄의 문자열을 통째로 반환 / sys.stdin: 여러줄 입력받을 때 # raw_line: 문자열을 반환 # input: raw_input을 evaluate한 결과를 반환   ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1927%EB%B2%88-%EC%B5%9C%EC%86%8C-%ED%9E%99/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1927%EB%B2%88-%EC%B5%9C%EC%86%8C-%ED%9E%99/","title":"백준 1927번 최소 힙"},{"content":"1931번 회의실 배정 문제 보러가기\n🅰 코드 n = int(input()) arr = [] for i in range(n): tmp = list(map(int, input().split())) arr.append(tmp) # 람다함수 쓰는것 익숙해지기!!! arr.sort(key=lambda x: (x[1], x[0])) count = 0 end = 0 for i in range(n): if end \u0026lt;= arr[i][0]: count += 1 end = arr[i][1] print(count) ✅ 후기  문제에서 주어지는 입력값을 받은 다음 lambda함수를 사용해 끝나는 시간과 시작하는 시간순으로 두번 정렬해주면 금방 해결할 수 있는 문제이다. 새삼 느끼지만 lambda함수는 정말 간단하고 편리한 것 같다. 자주 사용하는 버릇을 들여야 겠다;;😮  ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1931%EB%B2%88-%ED%9A%8C%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1931%EB%B2%88-%ED%9A%8C%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/","title":"백준 1931번 회의실 배정"},{"content":"1992번 쿼드트리 문제 보러가기\n🅰 코드 # 정답을 담을 변수 result = [] def Test(a): # 모두 0이거나 모두 1이면 끝 if sum( sum(a,[]) ) == 0 or len( sum(a,[]) ) == sum(a,[]).count(1): if sum( sum(a,[])) == 0: result.append(\u0026#39;0\u0026#39;) else: result.append(\u0026#39;1\u0026#39;) return else: result.append(\u0026#39;(\u0026#39;) div = int(len(a)/2) # a/2 x a/2 크기의 행렬을 만들기위해. tmp_l =[] # 좌측 tmp_r =[] # 우측 # 한행씩 불러온다. for sub in a: # 1/2 앞쪽 열 tmp_l.append(sub[0:div]) # 1/2 뒷쪽 열 tmp_r.append(sub[div:]) # tmp_l,tmp_r이 div x div 크기라면 if len(tmp_l) == div: Test(tmp_l) # 좌측값 Test(tmp_r) # 우측값 tmp_r = [] tmp_l = [] result.append(\u0026#39;)\u0026#39;) n = input() a = [] for i in range(int(n)): row = input() tmp = [] for v in row: tmp.append(int(v)) a.append(tmp) Test(a) print( \u0026#39;\u0026#39;.join(result) ) ✅ 후기   분할정복, 재귀를 이용한 문제로 큰 가닥을 잡지 못해서 굉장히 헤맸다. 그래서 인터넷의 도움을 사알짝 받긴 했지만\u0026hellip; 알고리즘은 다음과 같은 순서로 진행된다.\n1) 십자가로 쪼갠다.(분할) 2) 각각의 섹션을 확인한다. 3) 모두 0이거나 1이라면 출력한다. 아니면 반복한다. \r\n  ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1992%EB%B2%88-%EC%BF%BC%EB%93%9C%ED%8A%B8%EB%A6%AC/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1992%EB%B2%88-%EC%BF%BC%EB%93%9C%ED%8A%B8%EB%A6%AC/","title":"백준 1992번 쿼드트리"},{"content":"2579번 계단 오르기 문제 보러가기\n🅰 코드 import sys input = sys.stdin.readline n = int(input()) stairs = [] res = [] for i in range(n): stairs.append(int(input())) if n==1: print(stairs[0]) exit() elif n == 2: print(max(stairs[0]+stairs[1], stairs[1])) exit() res.append(stairs[0]) res.append(max(res[0]+stairs[1], stairs[1])) res.append(max(res[0]+stairs[2], stairs[1]+stairs[2])) for i in range(3, n): res.append(max(res[i-2]+stairs[i], res[i-3]+stairs[i-1]+stairs[i])) print(res[-1]) ✅ 후기   DP문제로 각 계단의 경우의 수마다 2가지의 경우를 고려하면서 진행해 나간다.\n첫번째 경우) 2계단 전에서 한번에 올라오는 경우 두번째 경우) 3계단 전에서 2계단 한번에 올라온 후 1계단 올라온 경우   ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-2579%EB%B2%88-%ED%9A%8C%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-2579%EB%B2%88-%ED%9A%8C%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/","title":"백준 2579번 회의실 배정"},{"content":"1676번 팩토리얼 0의 개수 문제 보러가기\n🅰 코드 # n 입력 (0 ~ 500) N = int(input()) # 팩토리얼 계산 # 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수 → 5의 개수 print(N//5 + N//25 + N//125) ✅ 후기  알고리즘 코딩 문제라기 보다는 그냥 창의력 문제인 느낌이 물씬 풍겼다. 규칙을 찾기 위해 30!까지 숫자를 나열해 보면서 코드에서도 나와 있듯이 5의 개수로 0의 개수가 정해지는 규칙이 있다. 여기서 주의 할 점이 5, 25, 125를 따로 생각해준 것처럼 5의 제곱 형태일 때는 여러개가 있기 때문에 이점을 고려해야 한다는 것이다. 💯  ","date":"2021-04-22T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1676%EB%B2%88-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC-0%EC%9D%98-%EA%B0%9C%EC%88%98/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1676%EB%B2%88-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC-0%EC%9D%98-%EA%B0%9C%EC%88%98/","title":"백준 1676번 팩토리얼 0의 개수"},{"content":"1697번 숨바꼭질 문제 보러가기\n🅰 설계   수빈이와 동생의 위치가 주어졌을때 수빈이가 동생의 위치로 이동할 수 있는 최소 거리를 찾는 것이 문제의 목표이다.\n  현재의 위치에서 이동할 수 있는 수단이 3가지이기 때문에 BFS로 접근하면 되겠다 생각하고 풀이해 나갔지만 문제에서 요구하는 정확한 알고리즘 구조를 짜기가 어려웠다\u0026hellip;💦\n  또한 처음에 또 실수한 부분이 아무생각 없이 list를 이용해 queue를 구현하려 했다는 것이다.\npython에서 list로 queue를 구현하면 시간복잡도가 O(n)으로 매우 느리다. 따라서 collections의 deque를 이용해야 하며, 이때 시간복잡도는 O(1)로 빠르다.\n  ✔ 정답 코드 구글링 from collections import deque def bfs(): q = deque() q.append(N) while q: v = q.popleft() if v == K: print(time[v]) return for next_step in (v-1, v+1, v*2): if 0 \u0026lt;= next_step \u0026lt; MAX and not time[next_step]: time[next_step] = time[v] + 1 q.append(next_step) MAX = 100001 N, K = map(int, input().split()) time = [0]*MAX bfs() ✅ 후기   아직까지도 BFS, DFS 를 내 입맛대로 자유롭게 구현하는 것이 어려웠고..\nD1이라는 난이도에 쫄았던 것 같다;; 많은 배움이 필요하다\u0026hellip;\n  ","date":"2021-04-22T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1697%EB%B2%88-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1697%EB%B2%88-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/","title":"백준 1697번 숨바꼭질"},{"content":"1764번 듣보잡 문제 보러가기\n🅰 코드 # N: 듣도 못한 사람 (~ 500000) # M: 보도 못한 사람 (~ 500000) N , M = map(int,input().split()) # 중복되는 이름을 없애기 위해 arr_N = set() arr_M = set() for _ in range(N): arr_N.add(input()) for _ in range(M): arr_M.add(input()) # 교집합 개수 출력 arr = sorted(list(arr_N \u0026amp; arr_M)) print(len(arr)) # 교집합 이름 출력 for i in arr: print(i) ✅ 후기   문제에서 주어진 대로 중복을 허용하지 않는 두개의 그룹SET으로 나누어 차례로 추가해주고 출력해주는 문제였다.\n  문제 진행에 있어 교집합을 구하는 부분이 등장하는데 이때 교집합 뿐만 아니라 합집합, 차집합 등 다양한 집합을 python으로 다루는 내용을 정리한 페이지를 참조했다.\n 참고로 대칭차집합은 합집합에서 교집합을 뺀 집합을 지칭한다.\n   ","date":"2021-04-22T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1764%EB%B2%88-%EB%93%A3%EB%B3%B4%EC%9E%A1/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1764%EB%B2%88-%EB%93%A3%EB%B3%B4%EC%9E%A1/","title":"백준 1764번 듣보잡"},{"content":"SSAFY(삼성 청년 SW 아카데미)👨‍🏫 \r\n삼성 청년 SW 아카데미(SSAFY)는 삼성의 SW 교육 경험과 고용노동부의 취업지원 노하우를 바탕으로 취업 준비생에게 SW 역량 향상 교육 및 다양한 취업지원 서비스를 제공하여 취업에 성공하도록 돕는 프로그램입니다.\n현재 저는 ssafy 5기를 진행중에 있고 이제 6기를 모집한다는 소식을 접하게 되어 보다 많은 사람들이 이 기회를 잡았으면 좋겠어서 글을 남기게 되었습니다!!!😎\n지원안내   지원자격\n연령 : 만 29세 이하\n학력 : 국내외 4년제 대학 졸업자 및 21.8월 졸업 예정자(전공무관)\n  재직여부 및 기타사항\n현재 미취업자 대상으로 교육시작일 교육 입과 가능한 자\n교육기간 중 통학 가능한 자\n병역필 또는 면제자로 해외여행에 결격 사유가 없는 자\n  교육생 지원내용\nSW교육 무료 제공 및 교육지원비 지급\n성정우수자 삼성전자 해외연구소 실습기회 부여\n교육 중 삼성 SW역량 테스트 응시기회 제공\n개인별 진로 컨설팅 등 다양한 취업지원 서비스 제공\n  보다 자세한 사항은 ssafy 홈페이지에 들어가면 확인하실 수 있습니다.\n또한 개인적으로 궁금한 사항은 qqq960909@likelion.org로 문의 주시면 알려줄 수 있는 범위 내에서 알려드리도록 하겠습니다!!\n","date":"2021-04-14T00:00:00Z","image":"https://ssabum.github.io/content/samsung-sw-academy-for-youth/ssafy_hue71d9469f60f090ffbbc678fbd9daff1_167607_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/samsung-sw-academy-for-youth/","title":"SAMSUNG SW ACADEMY FOR YOUTH"},{"content":"광주인공지능사관학교👩‍🏫 광주 인공지능사관학교는 멋쟁이사자처럼의 IT교육 노하우와 광주광역시 \u0026amp; 광주정보문화산업진흥원의 인공지능 클러스터 사업을 바탕으로 인공지능 특화 교육을 제공하여 AI 전문인재로 성장할 수 있도록 돕는 교육 프로그램입니다.\n\r\n작년에 개관하여 저는 광인사 1기를 수료하였고 현재 2기 모집을 마감한걸로 알고 있습니다. 2기 지원자들이나 광인사에 관심이 있으신 분들에게 도움을 드리기 위해 글을 남기게 되었습니다!!!😎\n지원안내   지원자격\n연령 : 만 39세 이하\n지역 : 전국 지원 가능 (광주 권역 50% 이상 선발 예정)\n  교육일정\n온라인 Pre → 중고급 과정 → 해커톤 → 프로젝트 → 취업지원 및 멘토링 특강\n  보다 자세한 사항은 광인사 안내 홈페이지에 들어가면 확인하실 수 있습니다.\n또한 개인적으로 궁금한 사항은 qqq960909@likelion.org로 문의 주시면 알려줄 수 있는 범위 내에서 알려드리도록 하겠습니다!!\n","date":"2021-04-14T00:00:00Z","image":"https://ssabum.github.io/content/%EA%B4%91%EC%A3%BC%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5%EC%82%AC%EA%B4%80%ED%95%99%EA%B5%90/%EA%B4%91%EC%9D%B8%EC%82%AC_hu719e3fdc9e4ff866a1cd41d00cfaa62f_468099_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EA%B4%91%EC%A3%BC%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5%EC%82%AC%EA%B4%80%ED%95%99%EA%B5%90/","title":"광주인공지능사관학교"},{"content":"빅데이터란  지구상에선 지금 이순간에도 방대한 크기volumn의 다양한varity 데이터들이 빠른 속도velocity로 발생하고 있다. 빅데이터는 이를 수용하며, 데이터의 진실성veracity을 확보하고, 분석 데이터를 시각화visualization함으로써 새로운 효이기을 가져다 줄 가치value를 창출하는 것이다.\n빅데이터는 수집 \u0026gt; 적재 \u0026gt; 처리 \u0026gt; 탐색 \u0026gt; 분석 \u0026gt; 응용의 단계를 거친다.\n 빅데이터 구현기술 \r\n파일럿 프로젝트 소개 다음과 같은 데이터를 가지고 빅데이터 프로젝트를 진행한다.\n 스마트카 상태 정보 데이터셋 스마트카 운전자 운행 데이터셋 스마트카 마스터 데이터셋 스마트카 물품구매 이력 데이터셋  소프트웨어 아키텍처 \r\n파일럿 프로젝트 구축 환경 \r\n 참고 문헌 실무로 배우는 빅데이터 기술\n","date":"2021-04-13T00:00:00Z","image":"https://ssabum.github.io/content/big-data-pilot-project/big_huc3341fa433694cc25a4a023e642e485d_212847_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/big-data-pilot-project/","title":"Big data pilot project"},{"content":"가상머신 정의💻 가상 머신(Virtual Machine, VM)은 컴퓨팅 환경을 소프트웨어로 구현한 것, 즉 컴퓨터를 에뮬레이션하는 소프트웨어다. 가상머신상에서 운영체제나 응용프로그램을 설치 및 실행할 수 있다.\n시스템 가상 머신 시스템 가상 머신은 때로 하드웨어 가상 머신이라고 하며 각 운영 체제를 실행하는 가상 머신 사이의 기초가 되는 물리 컴퓨터를 다중화(multiplex)한다. 가상화를 제공하는 소프트웨어 계층은 가상 머신 모니터 또는 하이퍼바이저라고 한다. 하이퍼바이저는 순 그대로의 하드웨어 또는 호스트 운영 체제 위에서 실행할 수 있다.\n시스템 가상 머신의 주요 이점\n 여러 운영 체제를 쓰는 환경은 운영 체제가 완벽히 고립된 채로 같은 컴퓨터에서 존재할 수 있다. 가상 머신은 실제의 컴퓨터가 제공하는 것과 다른 형태의 명령어 집합 구조 (ISA)를 제공한다.  즉, 다양한 OS를 제공하기 위해 멀티부팅의 어려움을 겪지 않아도 되고 각각은 서로 독립되어 있어 서로에게 영향을 미치지 않는다. 이는 관리에 용이성을 부여하고, 외부의 위험으로부터 분리된 환경이라 다양한 테스트 환경에 적합하다. 최근에는 서버를 가상화하여 사용자들에게 대여해주는 클라우드 호스팅이 유행하고 있는데, 이도 가상화 기술의 발전의 한 갈래이다.\n프로세스 가상 머신 VM은 응용 프로그램 가상 머신이라고도 하며, 운영 체제 안에서 일반 응용 프로그램을 돌리고 단일 프로세스를 지원한다. 프로세스가 시작하고, \u0026lsquo;끝내기\u0026rsquo;되어 파괴될 때 만들어진다. 목적은 플랫폼에서 다른 플랫폼 방식으로 실행하는 프로그램을 허용하고 기초가 되는 하드웨어나 운영 체제의 상세한 부분을 가져오는 독립 프로그래밍 환경을 제공하기 위함이다.\n가상 머신이라고 하는 프로세스는 고급 프로그래밍 언어에서 높은 수준의 추출을 제공며 해석기를 사용하여 추가된다.\n이러한 종류의 가상 머신은 자바 가상 머신을 사용하여 추가되는 자바와 더불어 인기를 끌었다. 또다른 예로는, 닷넷 프레임워크가 있는데 공통 언어 런타임라고 불리는 가상 머신을 실행한다.\n \r\n","date":"2021-04-13T00:00:00Z","image":"https://ssabum.github.io/content/%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD/code_hu696a336fe623223aab73a912217f27f7_1787389_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD/","title":"가상환경"},{"content":"정보처리기사👨‍💻 과학기술정보통신부에서 주관하고 한국산업인력공단에서 시행하는 국가자격 시험으로, 소프트웨어 개발, 정보시스템의 생명주기 전반에 걸친 프로젝트 업무를 수행하는 직무로서 계획수립, 분석, 설계, 구현, 시험, 운영, 유지보수 등의 업무를 수행할 수 있는 능력을 검증하는 시험이다.\n2020년부터 NCS 표준에 맞춰 시험 과목이 필기, 실기 모두를 포함해 대폭 개편되었다. 그래서 시작된 나의 오랜 정보처리기사도전기\u0026hellip;😥\n작년에 필기를 합격했지만 실기는 떨어지면서 오는 25일 새로운 도전을 앞두고 있다. 이제부터 시작이지만\u0026hellip;\u0026ldquo;제발, 당신의 기사가 될 수 있기를\u0026hellip;\u0026rdquo;\n","date":"2021-04-12T00:00:00Z","image":"https://ssabum.github.io/content/%EB%82%B4%EA%B0%80-%EB%8B%B9%EC%8B%A0%EC%9D%98-%EA%B8%B0%EC%82%AC%EA%B0%80-%EB%90%98%EC%96%B4-%EC%A4%84%EA%B2%8C%EC%9A%94/book_hu7396fba383e6517fd1fea0f069a72db2_3435619_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%82%B4%EA%B0%80-%EB%8B%B9%EC%8B%A0%EC%9D%98-%EA%B8%B0%EC%82%AC%EA%B0%80-%EB%90%98%EC%96%B4-%EC%A4%84%EA%B2%8C%EC%9A%94/","title":"내가 당신의 기사가 되어 줄게요"},{"content":"1463번 1로 만들기 문제 보러가기\n🅰 설계   문제에서 주어진 아래의 조건에 맞추어 코드를 구현하고 카운트의 최솟값을 구하는 알고리즘을 실행시켰지만 답이 나오지 않았다\u0026hellip;\n  x가 3으로 나누어 떨어지면, 3으로 나눈다.\n  x가 2로 나누어 떨어지면, 2로 나눈다.\n  1을 뺀다.\n    다음으로 연필로 써내려가면서 규칙이 있나 찾아보았다. 개인적으로 싫어하는 방법이지만 풀 방법이 생각나지 않아 도전해 보았다\u0026hellip;\n역시, 규칙은 보이지 않았다\u0026hellip;\n  ✔ 정답 코드 구글링 N = int(input()) dp_list = [0,0,1,1] # 0 ,1, 2, 3 의 최소 수 미리 저장 for i in range(4, N + 1) : # 먼저 1을 뺏을 경우 나오는 경우의 수 저장 dp_list.append(dp_list[i-1] + 1) #2로 나누어질 경우 기존 1을 뺏을 경우의 수와 비교하여 최솟값 저장 if i % 2 == 0 : dp_list[i] = min(dp_list[i], dp_list[i//2] + 1) #3으로 나누어질 경우 기존 1을 뺏을 경우의 수와 비교하여 최솟값 저장 #여기서 2 또는 3으로 나누어질 경우 모든 경우를 봐야하므로 elif가 아닌 if로 설정 if i % 3 == 0 : dp_list[i] = min(dp_list[i], dp_list[i//3] + 1) print(dp_list[-1]) ✅ 후기   1로 만들기문제는 큰 문제를 작은 문제로 단순화시켜 해결하는 다이나믹 프로그래밍문제이다.\n따라서 어떤 수 N에 대하여 최소 경우를 알고 싶다면 기본이 되는 점화식을 만들어야 한다.\n본 문제에서는 dp[N] = min(dp[N-1], dp[N//2] , dp[N//3]) + 1으로 점화식을 만들 수 있다.\n  N-1로 시작한 경우, N//2로 시작한 경우, N//3으로 시작한 경우, 각각의 경우의 수를 찾아 최소 경우의 수를 찾으면 되는 일이다.\n  점화식으로 풀어나가는 DP문제는 익숙치 않아서 어려운 것 같다\u0026hellip;💦\n  ","date":"2021-04-12T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1463%EB%B2%88-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1463%EB%B2%88-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/","title":"백준 1463번 1로 만들기"},{"content":"1541번 잃어버린 괄호 문제 보러가기\n🅰 코드 # \u0026#39;-\u0026#39;부호로 나눠진 문자열 저장 arr = input().split(\u0026#39;-\u0026#39;) # 결과 변수 생성 result = 0 # 처음 \u0026#39;-\u0026#39;부호가 나오는 부분까지 더하기 for i in arr[0].split(\u0026#39;+\u0026#39;): result += int(i) # 그 뒤엔 다 빼주는데 \u0026#39;+\u0026#39;부호로 묶인 것도 나눠서 빼기 → -(a+b) = -a-b for i in arr[1:]: for j in i.split(\u0026#39;+\u0026#39;): result -= int(j) print(result) ✅ 후기  문제에 주어진 문자열에서 차례로 연산을 하기만 하면 되는 비교적 쉬운 문제였다고 생각했지만 중간에 한번 함정이 있어서 고민이 필요했다\u0026hellip; 문제에서 요구하는 가장 최소의 값이 나오긴 위해서는 -부호 뒤에 오는 숫자들의 값이 커야 했으며 이를 표현하기 위해 -부호 뒤의 문자열에서 +부호로 나누어 각각을 빼주는 작업을 진행하였다. 평소 슬라이싱을 주로 사용했어서 비교적 쉽게 접근할 수 있었던 것 같다. 파이썬 조아😗  ","date":"2021-04-12T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1541%EB%B2%88-%EC%9E%83%EC%96%B4%EB%B2%84%EB%A6%B0-%EA%B4%84%ED%98%B8/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1541%EB%B2%88-%EC%9E%83%EC%96%B4%EB%B2%84%EB%A6%B0-%EA%B4%84%ED%98%B8/","title":"백준 1541번 잃어버린 괄호"},{"content":"1620번 나는야 포켓몬 마스터 이다솜 문제 보러가기\n🅰 코드 # 데이터 입력 N, M = map(int,input().split()) # 포켓몬을 \u0026#39;이름:번호\u0026#39;로 딕셔너리 생성 arr = [0] dict = {} for num in range(1,N+1): monster = input().strip() arr.append(monster) dict[monster] = num # 주어진 문제에 대해 숫자인지, 문자인지 판별 후 검색 for _ in range(M): q = input().strip() if q.isalpha() : print(dict[q]) elif q.isdigit() : print(arr[int(q)]) ✅ 후기  일단 문제를 읽기 싫었다\u0026hellip;포켓몬컨셉인건 알겠는데 사설이 너무 길다\u0026hellip; 나중에 기회가 된다면 내가 직접 깔끔하고 섹시한 문제를 만들어 올릴 것이다. 문제에 대한 접근은 리스트, 딕셔너리 형태로 문제에서 주어진 데이터들을 저장한 후 검색해 출력하는 문제이다. 예전에 python 처음 배울때 알아 두었던 내장함수 덕에 쉽게 접근 할 수 있었다. 역시 기본이 튼튼해야 문제를 쉽게 해결 할 수 있다.😮  ","date":"2021-04-12T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1620%EB%B2%88-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1620%EB%B2%88-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C/","title":"백준 1620번 나는야 포켓몬 마스터 이다솜"},{"content":"1003번_피보나치 함수 문제 보러가기\n🅰 설계 t = int(input()) for i in range(t): n = int(input()) # fib(0), fib(1), tmp 설정 zero, one, tmp = 1, 0, 0 # 피보나치 수행 for _ in range(n): tmp = one one = one + zero zero = tmp # 출력 print(zero, one) ✅ 후기 // 풀이과정\n 처음 문제를 읽고 어떻게 해야할지 풀이가 떠오르지 않아 꽤나 고생했다.😥 하지만 5까지의 경우의 수를 직접 표로 그려보니 간단한 문제임을 알 수 있었다. fib(0), fib(1)의 카운트를 담을 변수를 생성하고 n이 커질수록 증가하는 규칙을 찾아서 코드로 옮겨주기만 하면 되는 문제였다.👍  // 앞으로 다짐\n 문제 풀이가 떠오르지 않을 땐 무조건 노트에 그려보자!!!  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1003%EB%B2%88-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1003%EB%B2%88-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98/","title":"백준 1003번 피보나치 함수"},{"content":"1012번_유기농 배추 문제 보러가기\n🅰 설계 import sys sys.stdin = open(\u0026#34;input.txt\u0026#34;) T = int(input()) for tc in range(1, T+1): # m: 가로길이, n: 세로길이, k: 배추개수 m, n, k = map(int, input().split()) # 입력된 데이터에 맞춰 밭 만들어 주기 field = list(list(0 for i in range(m)) for _ in range(n)) # 밭에 배추 심기 for i in range(k): x, y = map(int, input().split()) field[y][x] = 1 # 지렁이 검사 cnt = 0 # 이후 접근을 어떻게 해야할지... 🅰 모범답안 t = int(input()) dx = [1, -1, 0, 0] dy = [0, 0, -1, 1] def bfs(x, y): queue = [[x, y]] while queue: a, b = queue[0][0], queue[0][1] del queue[0] for i in range(4): q = a + dx[i] w = b + dy[i] if 0 \u0026lt;= q \u0026lt; n and 0 \u0026lt;= w \u0026lt; m and s[q][w] == 1: s[q][w] = 0 queue.append([q, w]) for i in range(t): m, n, k = map(int, input().split()) s = [[0] * m for i in range(n)] cnt = 0 for j in range(k): a, b = map(int, input().split()) s[b][a] = 1 for q in range(n): for w in range(m): if s[q][w] == 1: bfs(q, w) s[q][w] = 0 cnt += 1 print(cnt) ✅ 후기   데이터를 받아오고 기본 base에 넣어주는 부분까지는 구현했지만 bfs를 돌면서 탐색하는 것이 아직 익숙치 않아 한참을 노트와 키보드만 끄적거리고 두들기다가 문제를 해결하지 못했다.\n  이후 검색을 통해 풀이방법을 알 수 있었고 보다 많음 bfs, dfs 문제를 풀어보면서 숙달해야겠다고 느꼈다.😨\n  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1012%EB%B2%88-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1012%EB%B2%88-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/","title":"백준 1012번 유기농 배추"},{"content":"1074번_Z 문제 보러가기\n🅰 설계 import sys result = 0 def z(n, x, y): global result # 기본이 되는 탈출 조건 생성 if x == r and y == c: print(int(result)) exit(0) if n == 1: result += 1 return # 처음에 시간초과 떠서 경우의 수도 합쳐 주었다. # 하지만 나중에 알고보니 할 필요 없었다... if not (x \u0026lt;= r \u0026lt; x + n and y \u0026lt;= c \u0026lt; y + n): result += n * n return # 재귀함수 z(n / 2, x, y) z(n / 2, x, y + n / 2) z(n / 2, x + n / 2, y) z(n / 2, x + n / 2, y + n / 2) # 시간초과 안나기 위해 sys.stdin.readline사용...sibal... n, r, c = map(int, sys.stdin.readline().split(\u0026#39; \u0026#39;)) z(2 ** n, 0, 0) ✅ 후기 // 풀이과정\n  문제에 주어진 그림을 보면서 이해를 쉽게 할 수 있었다.\n  다만 요건은 시간초과였다.\n시간초과를 없애기 위해 if문을 합쳐 보면서 어떻게든 줄여보려 했지만 결과는 시관초과\u0026hellip;\n  이후 검색을 통해 sys.stdin.readline()에 대해 알게 되었고 이를 이용해 해결 할 수 있었다.\nsys.stdin.readline사용법\n  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1074%EB%B2%88-z/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1074%EB%B2%88-z/","title":"백준 1074번 Z"},{"content":"1107번_리모컨 문제 보러가기\n🅰 코드 # N: 목표로 하는 채널번호(0~500000), M: 고장난 버튼의 개수(0~10) N = int(input()) M = int(input()) # button: 숫자 버튼 / 고장난 버튼이 있으면 빼준다 button = {i for i in range(10)} if M != 0: button -= set(map(int, input().split())) # 100번에서 N번으로 +, - 버튼만 쓴 경우 cnt = abs(100 - N) # 50만 채널인데 최악의 경우를 고려할 때 # 작은수에서 +만 사용(50만)에 큰수에서 -만 사용(50만)을 더하면 100만 가지의 경우의 수가 발생 for i in range(1000000): flag = True for j in str(i): if int(j) not in button: flag = False break if flag: # button으로 접근 할 수 있는 수에다가 목표 채널의 차이(+, - 으로 이동)를 더한 값 cnt = min(cnt, len(str(i)) + abs(N-i)) print(cnt) 🅰 \u0026amp;연산자 사용 ![1107](../../../../../../../../Users/qqq96/Desktop/1107.PNG)import sys n = int(sys.stdin.readline()) m = int(sys.stdin.readline()) li = set(list(sys.stdin.readline().split())) res = abs(100-n) for i in range(1000000): ba = set(list(str(i))) le = len(str(i)) if not ba\u0026amp;li: res = min(res,le+abs(n-i)) print(res) ✅ 후기  문제를 보는 순간 별 생각 없이 brute force로 풀면 되겠지라는 생각을 가지고 문제에 주어진 대로 최대 채널 수 만큼 500000까지로 설계해 주었다. 그러나 맞았습니다!!라는 문구는 보이지 않았고 고민 끝에 1000000으로 설계해줘야 한다는 사실을 깨달았다!! 우여곡절 끝에 문제를 해결하고 다른 사람들은 어떻게 풀었는지 살펴보는 와중 \u0026amp;연산자를 이용해 비교적 짧게 구현된 코드를 발견하게 되었다. 결과가 어떻게 나올지 궁금하여 두개를 돌려보았는데 다음과 같이 나왔다.  \r\n 산술연산자와 비트연산자에서는 비트연산자의 속도가 월등히 빠른 걸로 알고 있는데 이 경우에서는 반대의 결과가 나와서 신기했다. 물론 난 아직 이런 연산자를 쓰는 것이 익숙치 못해 이해도 어렵지만, 나중에는 자유롭게 구사하는 날이 오기를\u0026hellip;  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1107%EB%B2%88-%EB%A6%AC%EB%AA%A8%EC%BB%A8/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1107%EB%B2%88-%EB%A6%AC%EB%AA%A8%EC%BB%A8/","title":"백준 1107번 리모컨"},{"content":"1260번_DFS와 BFS 문제 보러가기\n🅰 코드 N,M,V=map(int,input().split()) matrix=[[0]*(N+1) for i in range(N+1)] for i in range(M): a,b = map(int,input().split()) matrix[a][b]=matrix[b][a]=1 visit_list=[0]*(N+1) def dfs(V): visit_list[V]=1 print(V, end=\u0026#39; \u0026#39;) for i in range(1,N+1): if(visit_list[i]==0 and matrix[V][i]==1): dfs(i) def bfs(V): queue=[V] visit_list[V]=0 while queue: V=queue.pop(0) print(V, end=\u0026#39; \u0026#39;) for i in range(1, N+1): if(visit_list[i]==1 and matrix[V][i]==1): queue.append(i) visit_list[i]=0 dfs(V) print() bfs(V) ✅ 후기  문제 자체는 SSAFY교육에도 진행되었던 DFS, BFS의 가장 기본인 코드를 구현하는 것이었다. 그렇기에 어렵지는 않았지만, 궁극적인 목표는 어떤 문제에는 어떤 알고리즘으로 구현하는 것이 더 어울리는지 문제를 보고 바로 아는 것인것 같다. 그러므로 더욱 노력해야 할것 같다;;  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1260%EB%B2%88-dfs%EC%99%80-bfs/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1260%EB%B2%88-dfs%EC%99%80-bfs/","title":"백준 1260번 DFS와 BFS"},{"content":"1389번_케빈 베이컨의 6단계 법칙 문제 보러가기\n🅰 코드 from collections import deque def bfs(num, n): # 기본 base setting bacon = [0] * (n + 1) visited = [num] queue = deque() queue.append(num) while queue: # queue에서 popleft사용 k = queue.popleft() for i in relation[k]: if i not in visited: bacon[i] = bacon[k] + 1 visited.append(i) queue.append(i) return sum(bacon) # n: 유저수(2~100), m: 관계수(1~5000) n, m = map(int, input().split()) # 관계 dict생성 후 입력 relation = {i: [] for i in range(1, n + 1)} for i in range(m): a, b = map(int, input().split()) relation[a].append(b) relation[b].append(a) result = [] for num in range(1, n + 1): result.append(bfs(num, n)) # index로 최소 관계를 구하고 관계이기 때문에 1을 더해준다 print(result.index(min(result)) + 1) ✅ 후기  BFS를 이용하여 풀어내는 문제였다. 알고리즘 문제를 풀때마다 느끼는 거지만, 알고리즘 이해 자체는 어렵지 않지만 그것을 이용하여 문제를 풀어내는 것은 굉장히 어려운 것 같다;; 여담이지만 케빈 베이컨처럼 야리꾸리한 문제를 만들어서 자기이름을 붙이는 작자들은 도대체 어떤 사람들인지 궁금하다\u0026hellip;🥴  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1389%EB%B2%88-%EC%BC%80%EB%B9%88-%EB%B2%A0%EC%9D%B4%EC%BB%A8%EC%9D%98-6%EB%8B%A8%EA%B3%84-%EB%B2%95%EC%B9%99/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1389%EB%B2%88-%EC%BC%80%EB%B9%88-%EB%B2%A0%EC%9D%B4%EC%BB%A8%EC%9D%98-6%EB%8B%A8%EA%B3%84-%EB%B2%95%EC%B9%99/","title":"백준 1389번 케빈 베이컨의 6단계 법칙"},{"content":"SQL 개념  https://www.sqlitetutorial.net/\nSQL(StructuredQueryLanguage)는 관계형 데이터베이스 관리시스템(RDBMS)의데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어이다.\n SQL 문법의 세가지 종류\n DDL - 데이터 정의 언어  CREATE DROP ALTER RENAME   DML - 데이터 조작 언어  INSERT UPDATE DELETE SELECT   DCL - 데이터 제어 언어  GRANT REVOKE COMMIT ROLLBACK    Database 생성  해당하는 데이터베이스 파일이 있으면 해당DB를 콘솔로 연다.\n만약 해당하는 파일이 없으면 새로 생성하고, 해당 DB를 콘솔로 연다.\n $ sqlite3 database ex) $ sqlite3 tutorial.sqlite3 -- 1. 콘솔로 DB를 열고, sqlite\u0026gt; .databases -- 2.데이터베이스 목록을 확인한다. CSV 파일 불러오는 명령어\n 주의사항)\n.으로 시작하는 모든 명령어는 sqlite3 프로그램의 기능을 실행하는 명령어이며, SQL 문법에 속하지 않습니다.\n sqlite\u0026gt; .mode csv sqlite\u0026gt; .import 파일명.csv 테이블명 ex) sqlite\u0026gt; .import users.csv users_user 테이블 생성 및 삭제  데이터 타입의 종류는 INTEGER, TEXT, REAL, NUMERIC, BLOB 등이 존재한다.\n자세한 내용은 SQLite3 공식문서를 참조한다.\n 테이블 생성 (CREATE)\nCREATE TABLE table ( column1 datatype PRIMARY KEY, column2 datatype, ... );  INTEGER PRIMARY KEY 타입으로 컬럼 생성시 기본 rowid 를 대체함 단, PRIMARY KEY는 INTEGER 타입에서만 사용가능  데이터 타입\n NULL / INTEGER / REAL / TEXT / BLOB   INT와 INTEGER의 차이\nINT형은 산술연산이 가능하며 NULL로 초기화가 불가능하다\nINTEGER형은 산술연산이 불가능하며 NULL로 초기화가 가능하다\n 테이블 생성 with NOT NULL 조건 예시\nCREATE TABLE table ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INT NOT NULL, ... ); AUTOINCREMENT\n 이전의 삭제된 데이터의 pk는 재사용하지 않음  테이블 및 스키마 조회\nsqlite\u0026gt; .tables -- 테이블 목록 조회 sqlite\u0026gt; .schema table -- 특정 테이블 스키마 조회 테이블 제거 (DROP)\nsqlite\u0026gt; DROP TABLE classmates; sqlite\u0026gt; .tables -- 테이블 제거 확인 데이터 추가, 읽기, 수정 및 삭제 추가 (INSERT)\nINSERT INTO table (column1, column2) VALUES (value1, value2); INSERT INTO table (column1, column2) VALUES (value1, value2), (value1, value2), (value1, value2); id 스키마를 직접 작성 했을 때 데이터 추가 방법\n  모든 컬럼 작성 시\nINSERT INTO table (column1, column2) VALUES (value1, value2);   컬럼 미작성 시에는 직접 id 값 입력\nINSERT INTO table VALUES (2, value1, value2);   조회 (SELECT)\n SQL은 세미콜론(;)을 만나기 전까지 절대 실행되지 않습니다.\n따라서 아래 LIMIT 예시와 같이 들여쓰기를 비교적 자유롭게 할 수 있습니다.\n -- 모든 컬럼 가져오기 -- SELECT * FROM table; -- 특정 컬럼 가져오기 -- SELECT column1, column2 FROM table; -- LIMIT: 원하는 개수(num)만큼 가져오기 -- SELECT column1, column2 FROM table LIMIT num; -- OFFSET: 특정 위치에서부터 가져올 때 -- -- (맨 위부터 num만큼 떨어진 값부터 가져온다는 의미) SELECT column1, column2 FROM table LIMIT num OFFSET num; -- WHERE: 조건을 통해 값 가져오기 -- SELECT column1, column2 FROM table WHERE column=value; -- DISTINCT: 중복없이 가져오기 -- SELECT DISTINCT column FROM table; 삭제 (DELETE)\nDELETE FROM table WHERE condition; -- ex) DELETE FROM classmates WHERE name=\u0026#39;지연\u0026#39;; 수정 (UPDATE)\nUPDATE table SET column1=value1, column2=value2, ... WHERE condition; -- ex) -- 지연의 이름을 지수로 바꾼다고 하면 -- UPDATE classmates SET name=\u0026#39;지수\u0026#39;, address=\u0026#39;대한민국\u0026#39; WHERE name=\u0026#39;지연\u0026#39;; 예시와 함께하는 WHERE문 심화 (READ)\n-- Q.users에서 age가 30이상인 사람만 가져온다면? --  SELECT * FROM users WHERE age \u0026gt;= 30; -- Q.users에서 age가 30이상인 사람의 이름만 가져온다면? --  SELECT first_name FROM users WHERE age \u0026gt;= 30; -- Q.users에서 age가 30이상이고 성이 김인 사람의 성과 나이만 가져온다면? --  SELECT age, last_name FROM users WHERE age \u0026gt;= 30 and last_name=\u0026#39;김\u0026#39;; 심화 SQL문 Expressions  django ORM에서 aggregate와 대응\n   COUNT (레코드 값들의 개수 반환)\nSELECT COUNT(*) FROM users;   AVG (레코드 값들의 평균값 반환)\nSELECT AVG(age) FROM users WHERE age \u0026gt;= 30;   MAX (레코드 값들의 최대값 반환)\n  MIN (레코드 값들의 최소값 반환)\n  SUM (레코드 값들의 합 반환)\n  LIKE  LIKE는 두 가지 와일드 카드(언더스코어 그리고 퍼센트 기호)와 함께 동작한다.\n   _ (반드시 이 자리에 한 개의 문자가 존재해야 한다는 뜻)\n-- 20대인 사람들만 가져올 때 --  SELECT * FROM users WHERE age LIKE \u0026#39;2_\u0026#39;;   % (이 자리에 문자열이 있을 수도, 없을 수도 있다. 0개 이상이라는 뜻)\n-- 지역번호가 02인 사람만 가져올 때 --  SELECT * FROM users WHERE phone LIKE \u0026#39;02-%\u0026#39;;   두 개를 조합해서 사용할 수도 있다.\n-- 핸드폰 중간 번호가 반드시 4자리면서 511로 시작되는 사람들 --  SELECT * FROM users WHERE phone LIKE \u0026#39;%-511_-%\u0026#39;;   정렬 (ORDER BY)\nSELECT columns FROM table ORDER BY column1, column2 ASC | DESC; -- ASC: 오름차순 / DESC: 내림차순 -- -- 나이, 성 순서로 오름차순 정렬하여 상위 10개만 뽑아보면? --  SELECT * FROM users ORDER BY age, last_name LIMIT 10; GROUP BY\n 지정된 기준에 따라 행 세트를 그룹으로 결합한다.\n데이터를 요약하는 상황에서 주로 사용한다.\n django ORM에서 annotate와 대응   SELECT column1, aggregate_function(column_2) FROM table GROUP BY column1, column2; -- 성(last_name)씨가 몇 명인지 조회할 때 -- SELECT last_name, COUNT(*) FROM users GROUP BY last_name; ALTER\n 테이블명 변경  ALTER TABLE 기존테이블명 RENAME TO 새로운테이블명; 새로운 컬럼 추가  ALTER TABLE 테이블명 ADD COLUMN 컬럼명 datatype; ","date":"2021-04-04T00:00:00Z","image":"https://ssabum.github.io/content/sql%EB%AC%B8%EB%B2%95/sql_hubbf8a9fc18cf0c0587203e8c4fcd3fa5_78275_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/sql%EB%AC%B8%EB%B2%95/","title":"SQL문법"},{"content":"외장SSD?  외장하드, 즉 외장HDD는 많이들 들어보았을 것이다. 외장SSD는 HDD 대신 SSD를 사용하여 만들어낸 외장 메모리 저장장치이다. SSD는 HDD와 비교해 데이터 전송 속도가 빠르고, 전력 소모가 적으며, 플래터, 모터, 헤드 같은 부품이 없기 때문에 더 작고 얇게 제작할 수 있다.\n따라서 외장SSD 역시 단일 저장장치에서도 HDD 수준의 저장 용량을 확보할 수 있게 됐고, 입출력 인터페이스 역시 SSD의 빠른 속도를 선보이면서 휴대용 저장장치에 어울리는 방식으로 자리잡았다.\n외장SSD의 가장 큰 장점은 전송 속도다. HDD는 바늘 처럼 생긴 헤드를 플래터 위에서 직접 움직이며 데이터를 찾거나 데이터를 기록하는 반면, 반도체로 제작한 SSD는 이러한 과정이 없는 만큼 더 빠르게 데이터를 읽고 쓸 수 있다.\n 그래서 나도! 내 노트북의 용량은 SSD256GB이다. 그러나 필수 소프트웨어가 깔리고 프로그램과 파일들 몇 개 깔다보니 금방 금방 줄어들었다\u0026hellip;\n그래서 고민끝에 구매하게된 삼성 포터블 외장SSD T5 ㅎㅎ 통장 잔고가 좋지 못해 500GB짜리를 샀지만 나름 FLEX했다.\n그렇게 구매하고 배송받은 외장SSD를 연결하는 순간\u0026hellip;C tpye 연결시에 접촉 불량이 발생했다\u0026hellip;\n\r\n바로 삼성서비스센터에 무상교체를 보낸 상태이다\u0026hellip;\n빨리 정상작동되는 새걸로 받아서 가득 채워버려야지\u0026hellip;🤪\n그때부터 Big data 포스팅 시작이다!\n","date":"2021-04-04T00:00:00Z","image":"https://ssabum.github.io/content/%EC%99%B8%EC%9E%A5ssd/ssd_hu01a8af33eb5f2295d769ee49d18187fb_121432_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/%EC%99%B8%EC%9E%A5ssd/","title":"외장SSD"},{"content":"CSS  스타일, 레이아웃 등을 통해 HTML이 사용자에게 어떻게 표시 되는지를 지정하는 언어\n사용자에게 문서(HTML)를 표시하는 방법을 지정하는 언어\n CSS 구문  구문은 선택자와 함께 열린다. 스타일을 지정할 html 요소를 선택. 다음 중괄호가 있는데 이 안에는 속성과 값 쌍 형태를 가지는 하나 또는 그 이상의 선언(declaration)이 있다. 각 쌍은 우리가 선택한 요소의 속성을 지정하고 속성에 부여할 값을 지정한다.  선언문\n 속성 (Property)  사람이 읽을 수 있는 식별자로, 어떤 (글꼴, 너비, 배경색 등) 스타일 기능을 변경할지 나타냅니다.   값 (Value)  각 속성에는 값을 부여한다. 값은 어떻게 (글꼴을 이걸로, 배경 색을 저걸로 등)스타일 기능을 변경할 건지 나타낸다.    CSS 정의 방법\n Inline style 내부 참조 (Embedding style) 외부 참조 (Link style)   CSS Selector  선택자는 스타일을 지정할 웹 페이지의 HTML 요소를 대상으로 하는 데 사용\n 클래스(class) 선택자\n 클래스 선택자는 마침표( .) 문자로 시작 하며 해당 클래스가 적용된 문서의 모든 항목을 선택  아이디(id) 선택자\n 아이디 선택자는 # 문자로 시작하며 기본적으로 클래스 선택자와 같은 방식으로 사용 그러나 아이디는 문서 당 한 번만 사용할 수 있으며 요소에는 단일 id값만 적용 할 수 있다 문서에서 동일한 아이디를 여러 번 사용해도 동작하나 그렇게 하면 안된다.  결합자(combinators)\n 자손 결합자  셀렉터A  (공백) 셀렉터B 셀렉터A의 모든 후손 요소(level n) 중 셀렉터B와 일치하는 요소 선택   자식 결합자  셀렉터A \u0026gt; 셀렉터B 셀렉터A의 모든 자식 요소(level 1) 중 셀렉터B와 일치하는 요소 선택   일반 형제 결합자  셀렉터A ~ 셀렉터B 셀렉터A의 형제 요소 중 셀렉터A 뒤에 위치하는 셀렉터B 요소를 모두 선택   인접 형제 결합자  셀렉터A + 셀렉터B 셀렉터A의 형제 요소 중 셀렉터A 바로 뒤에 위치하는 셀렉터B 요소를 선택 단, A와 B 사이에 다른 요소가 존재하면 선택되지 않음    적용 우선순위\n !important  다른 사람들의 코드에서 발견할 때 그 의미를 알 수 있는 것은 좋다. 하지만 반드시 필요한 경우가 아니면 절대 사용하지 않는 것이 좋다., !important 는 cascading이 정상적으로 작동하는 방식을 변경하므로, CSS 스타일 문제를 해결하기가 어렵습니다.   inline style id 선택자  id는 대부분의 다른 선택자보다 우선순위가 높기 때문에 다루기가 어려워 질 수 있다. 대부분의 경우 id 보다는 모두 class 선택자로 작성하는 것이 좋다. 만약 문서 내 링크 이동이나 for를 사용하는 특별한 경우에만 아이디를 사용한다.   class 선택자 요소 선택자 소스 순서   CSS 단위 (상대) 크기 단위\npx\n 모니터 해상도의 한 화소인 \u0026lsquo;픽셀\u0026rsquo;을 기준 픽셀의 크기는 변하지 않기 때문에 고정적인 단위  %\n 백분율 단위 가변적인 레이아웃에서 자주 사용  em\n em은 상속의 영향 받음, rem은 최상위 요소(html)를 기준으로 결정됨. 상황에 따라 각기 다른 값을 가질 수 있다.  rem\n 최상위 요소인 html(root em)을 절대 단위를 기준으로 삼음. 상속의 영향을 받지 않음. 상속에 영향을 받지 않기 때문에 대부분의 경우 rem 을 많이 사용한다.  viewport\n (스크롤을 내리지 않은 상태에서) 웹 페이지를 방문한 유저에게 현재 보이는 웹 컨텐츠의 영역 viewport를 기준으로한 상대적인 사이즈 주로 스마트폰이나 테블릿 디바이스의 화면을 일컫는 용어로 사용된다. vw, vh  색상 표현 단위\n 색상 키워드  색상 키워드는 대소문자를 구분하지 않는 식별자로, red, blue, black처럼 특정 색을 나타낸다   RGB 색상  빨강, 초록, 파랑을 통해 특정 색을 표현 16진수 표기법이나 함수형 표기법으로 사용 a는 alpha(투명도)가 추가된 것   HSL 색상  색상, 채도, 명도를 통해 특정 색상을 표현 a는 alpha(투명도)가 추가된 것     Box Model  웹 디자인은 contents를 담을 box model을 정의하고 CSS 속성을 통해 스타일(배경, 폰트와 텍스트 등)과 위치 및 정렬을 지정하는 것.\n  모든 HTML 요소는 box 형태로 되어있다. 하나의 박스는 네 부분(영역)으로 이루어 진다.  content / padding / border / margin     Content  글이나 이미지, 비디오 등 요소의 실제 내용   Padding (안쪽 여백)  Border(테두리) 안쪽의 내부 여백 배경색, 이미지 지정 가능   Border Margin (바깥쪽 여백)  테두리 바깥의 외부 여백 배경색 지정 불가    마진 상쇄\n block의 top 및 bottom margin이 때로는 (결합되는 마진 중 크기가) 가장 큰 한 마진으로 결합(combine, 상쇄(collapsed))된다.   Display  display CSS 속성은 요소를 블록과 인라인 요소 중 어느 쪽으로 처리할지와 함께 자식 요소를 배치할 때 사용할 레이아웃을 설정한다.\n block\n 쌓이는 박스 요소는 블록 요소 상자를 생성하여 일반 흐름에서 요소 앞뒤에 줄 바꿈을 생성한다. 블록 레벨 요소안에 인라인 레벨 요소가 들어갈 수 있다.  inline\n 줄바꿈이 일어나지 않는 행의 일부 요소 content 너비만큼 가로 폭을 차지 width, height, margin-top, margin-bottom을 지정할 수 없음 상하 여백은 line-height로 지정  inline-block\n inline 처럼 텍스트 흐름대로 나열, block처럼 박스 형태이기 block 속성 사용가능  none\n 해당 요소를 화면에서 사라지게 하며 요소의 공간조차 사라지게 한다. visibility: hidden;은 해당 요소를 화면에서 사라지게는 하나 공간은 사라지지 않는다.   Position 박스의 위치 속성 \u0026amp; 값\n position  static / absolute / relative / fixed z-index    기본 개념\n static (기본 위치)  모든 태그의 기본 태그의 default 값   relative (상대 위치)  기본 위치(static)를 기준으로 좌표 속성을 사용해 위치 이동   absolute (절대 위치)  static 이 아닌 부모/조상 요소를 기준으로 좌표 속성 만큼 이동 부모 요소를 찾아가고 나아가 없다면 body에 붙는다.   fixed (고정 위치)  부모/조상 요소와 관계없이 브라우저의 viewport를 기준으로 좌표 속성 만큼 이동 스크롤을 내리거나 올려도 화면에서 사라지지 않고 항상 같은 곳에 위치    absolute\n absolute는 원래 위치해 있었던 과거 위치에 있던 공간은 더 이상 존재하지 않는다는 점이 특징이다. 즉, 다른 모든 것과는 별개로 독자적인 곳에 놓이게 된다. 대체 언제 쓸까?  페이지의 다른 요소의 위치와 간섭하지 않는 격리된 사용자 인터페이스 기능을 만들 수 있다. 팝업 정보 상자 및 제어 메뉴, 롤오버 패널, 페이지 어느 곳에서나 끌어서 놓기할 수 있는 유저 인터페이스 페이지 등     참고문헌 https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors\nhttps://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance\nhttps://developer.mozilla.org/ko/docs/Web/CSS/inheritance\nhttps://developer.mozilla.org/ko/docs/Web/HTML/Block-level_elements\nhttps://developer.mozilla.org/ko/docs/Web/HTML/Inline_elements\nhttps://developer.mozilla.org/ko/docs/Web/CSS/display\nhttps://docs.emmet.io/cheat-sheet/\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/css%EA%B8%B0%EC%B4%88/css_hu42497fb400a464be61c8fe27b05f0811_45708_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/css%EA%B8%B0%EC%B4%88/","title":"CSS기초"},{"content":"CSS Layout  웹페이지에 포함되는 요소들을 어떻게 취합하고 그것들이 어느 위치에 놓일 것인지를 제어한다.\n float  한 요소(element)가 정상 흐름(normal flow)으로부터 빠져 텍스트 및 인라인(inline) 요소가 그 주위를 감싸 자기 컨테이너의 좌,우측을 따라 배치되어야 함을 지정한다.\n clearfix\n  float 요소와 다른 텍스트가아닌 block 요소간의 레이아웃 깨짐을 막기 위해 다음과 같이 작성한다.\n/* float 속성을 적용한 요소의 부모요소에 적용한다. */ /* 부모 태그 다음에 가상 요소(::after)로 내용이 빈(content:\u0026#34;\u0026#34;) 블럭(display: block;)을 만들고 */ /* 이 가상요소는 float left,right(both)를 초기화 한다는 뜻 */ .clearfix::after { content: \u0026#34;\u0026#34;; display: block; clear: both; }   정리\n flexbox 및 그리드 레이아웃과 같은 기술이 나오기 이전에 float는 열 레이아웃을 만드는데 사용되었다. mdn에서는 더 새롭고 나은 레이아웃 기술이 나와있으므로 레거시 레이아웃 기술로 분류해놓기도 했다. 결국 원래 텍스트 블록 내에서 float 이미지를 위한 역할로 돌아간 것이다. 여전히 사용하는 경우도 있다. (ex. naver nav bar)   flexbox  일명 flexbox라 불리는 Flexible Box module은 flexbox 인터페이스 내의 아이템 간 공간 배분과 강력한 정렬 기능을 제공하기 위한 1차원 레이아웃 모델로 설계되었다.\n웹페이지의 컨테이너에 아이템의 폭과 높이 또는 순서를 변경해서 웹페이지의 사용 가능한 공간을 최대한 채우고 이를 디바이스 종류에 따라 유연하게 반영하도록 하는 개념\n 핵심 개념\n 요소  flex container flex items   축  maix axis (주축) cros axis (교차축)    flex container\n flexbox 레이아웃을 형성하는 가장 기본적인 모델 flexbox가 놓여있는 영역 flex 컨테이너를 생성하려면 영역 내의 컨테이너 요소의 display 값을 flex 혹은 inline-flex로 지정 flex 컨테이너를 선언시 아래와 같이 기본 값이 지정  item은 행으로 나열 item은 주축의 시작 선에서 시작 item은 교차축의 크기를 채우기 위해 늘어남 flex-wrap 속성은 nowrap으로 지정    Tip !\rjustify - main axis\ralign - cross axis\rcontent - 여러 줄\ritems - 한 줄\rself - 개별 요소\rflex-direction\n 쌓이는 방향 설정 (main-axis 의 방향만 바뀜. flex 는 single-direction layout concept 이기 때문)\n  row (기본값)  가로로 요소가 쌓임 row 는 주축의 방향을 왼쪽에서 오른쪽으로 흐르게 한다.   row-reverse column  세로로 요소가 쌓임 column 은 주축의 방향을 위에서 아래로 흐르게 한다.   column-reverse  flex-wrap\n item들이 강제로 한 줄에 배치 되게 할 것인지 여부 설정\n  nowrap (기본 값)  모든 아이템들 한 줄에 나타내려고 함 (그래서 자리가 없어도 튀어나옴)   wrap : 넘치면 그 다음 줄로 wrap-reverse : 넘치면 그 윗줄로 (역순)  flex-flow\n flex-direction 과 flex-wrap 의 shorthand\n flex-flow: row nowrap; justify-content\n main axis 정렬\nflex-direction: row 기준으로 작성됨\n  flex-start (기본 값)  시작 지점에서 쌓임(왼쪽 → 오른쪽)   flex-end  쌓이는 방향이 반대 (flex-direction: row-reverse 와는 다르다. 아이템의 순서는 그대로 정렬만 우측에 되는 것.)   center space-between  좌우 정렬 (item 들 간격 동일)   space-around  균등 좌우 정렬 (내부 요소 여백은 외곽 여백의 2배)   space-evenly  균등 정렬 (내부 요소 여백과 외각 여백 모두 동일)    align-items\n cross axis 여러 줄 정렬\nflex-direction: row 기준으로 작성됨\n  stretch (기본 값)  컨테이너를 가득 채움   flex-start  위   flex-end  아래   center baseline  item 내부의 text에 기준선을 맞춤    align-self\n align-items 와 동일 (단, 개별 item 에 적용)\n  auto (기본 값) flex-start flex-end center baseline stretch  부모 컨테이너에 자동으로 맞춰서 늘어난다. (Stretch \u0026lsquo;auto\u0026rsquo;-sized items to fit the container)    order\n 기본 값 : 0 작은 숫자 일수록 앞(왼쪽)으로 이동.  flex-grow\n 기본 값 : 0 주축에서 남는 공간을 항목들에게 분배하는 방법 각 아이템의 상대적 비율을 정하는 것이 아님 음수는 불가능   Bootstrap  The most popular HTML, CSS, and JS library in the world.\n   트위터에서 시작된 오픈 소스 프론트엔드 라이브러리\n  웹 페이지에서 많이 쓰이는 요소를 거의 전부 내장하고 있다.\n  디자인을 할 시간이 크게 줄어들고, 여러 웹 브라우저를 지원하기 위한 크로스 브라우징에 골머리를 썩일 필요가 없다.\n  웹 브라우저 크기에 따라 자동으로 정렬되는 \u0026ldquo;그리드 시스템\u0026quot;을 지원하며,\n  \u0026ldquo;one souce multi use\u0026rdquo; → 반응형 웹 디자인을 추구한다.\n  Responsive web design\n layout은 방문자의 화면 해상도를 고려하여야 한다. 스마트폰이나 태블릿 등 모바일 기기는 화면이 작기 때문에 가독성에 더욱 신경써야 한다. 보통 웹사이트가 축소되어 가로 스크롤 없이 콘텐츠를 볼 수 있으나 글자가 너무 작아지기 때문이다. 데스크탑용, 테블릿용, 모바일용 웹사이트를 별도 구축할 수도 있지만 One Source Multi Use의 관점에서 올바른 해결책은 아니다. 반응형 웹 디자인(Responsive Web Design)은 화면 해상도에 따라 가로폭이나 배치를 변경하여 가독성을 높여 이러한 문제를 해결한다. 즉, 하나의 웹사이트를 구축하여 다양한 디바이스의 화면 해상도에 최적화된 웹사이트를 제공하는 것이다.   Bootstrap Grid System Grid System\n 부트스트랩의 grid system 은 containers, rows 그리고 columns 를 사용해서 컨텐츠를 레이아웃하고 정렬한다. 모바일 우선 flexbox grid 를 사용하여 12개의 column 시스템을 가지고 있다. 왜 12 columns 일까 ?  12는 약수가 가장 많기 때문에 한 줄에 표시할 수 있는 종류가 제일 많다.   다음과 같은 구조로 사용한다.  .container \u0026gt; .row \u0026gt; col-*    .row\n row 는 columns 의 wrapper 이다. 각 column 에는 공간 사이를 제어하기 위한 좌우 padding 값이 있는데 이를 gutter 라고도 한다.  row 의 margin 값과 gutter 를 제거하려면 .row 에 .no-gutters class 를 사용한다.    .col / .col-*\n column class 는 row 당 가능한 12개 중 사용하려는 columns 수를 나타낸다. columns 너비는 백분율로 설정 되므로 항상 부모 요소를 기준으로 유동적으로 크기가 조정된다. grid layout 에서 내용은 반드시 columns 안에 있어야 하며 그리고 오직 columns 만 row 의 바로 하위 자식 일 수 있다.  offset\n offset-* 은 지정한 만큼의 column 공간을 무시하고 다음 공간부터 컨텐츠를 적용한다.  Nesting\n .row \u0026gt; .col-* \u0026gt; .row \u0026gt; .col-* 의 방식으로 중첩 사용 가능하다.  Grid breakpoints\n 부트스트랩 grid system 은 다양한 디바이스에서 적용하기 위해 특정 px 조건에 대한 지점을 정해 두었는데 이를 breakpoints 라고 한다. 부트스트랩은 대부분의 크기를 정의하기 위해 em 또는 rem 을 사용하지만 px 는 그리드 breakpoint 에 사용된다. (뷰포트 너비가 픽셀 단위이고 글꼴 크기에 따라 변하지 않기 때문)   마무리  각각의 기술은 저마다 용도가 있고, 장단점이 있으며, 독립적인 용도를 갖추도록 설계된 기술은 없다.\n특정 상황에 어떤 기술이 가장 적합한 도구가 될 것인지 파악하는 데에는 많은 경험이 필요하다.\n  참고문헌 https://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Introduction\nhttps://developer.mozilla.org/ko/docs/Web/CSS/float\nhttps://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Floats\nhttps://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Flexbox\nhttps://developer.mozilla.org/ko/docs/Web/CSS/CSS_Flexible_Box_Layout/Flexbox%EC%9D%98_%EA%B8%B0%EB%B3%B8_%EA%B0%9C%EB%85%90\nhttps://css-tricks.com/snippets/css/a-guide-to-flexbox/\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/css%EA%B8%B0%EC%B4%88-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/css_hu42497fb400a464be61c8fe27b05f0811_45708_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/css%EA%B8%B0%EC%B4%88-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/","title":"CSS기초 레이아웃"},{"content":"Django wep programming  파이썬으로 만들어진 무료 오픈소스 웹 애플리케이션 프레임워크\n즉, 쉽고 빠르게 웹사이트를 개발할 수 있도록 돕는 구성요소로 이루어진 웹 프레임워크\n여기서 프레임워크란, 애플리케이션 개발에 바탕이 되는 템플릿과 같은 역할을 하는 클래스들과 인터페이스의 집합\n 기본 생성 파일  mysite: 프로젝트를 담는 공간 manage.py: 프로젝트와 다양한 방법으로 상호작용 하는 커맨드라인의 유틸리티 init.py: 파이썬으로 하여금 이 디렉토리를 패키지처럼 다루라고 알려주는 용도의 빈 파일 setting.py: 현재 프로젝트의 환경 및 구성을 저장 urls.py: 현재 프로젝트의 URL선언을 저장 wsgi.py: 현재 프로젝트를 서비스하기 위한 WSGI 호환 웹 서비의 진입점  django cycle \r\ndjango 명령어 # 프로젝트 생성 $ django-admin startproject 프로젝트명 # 앱 생성 $ python manage.py startapp 앱명 # 서버가 제대로 동작하는지 로컬에서 확인, http://127.0.0.1:8000/에서 출력 $ python manage.py runserver # INSTALLED_APPS 설정을 탐색하여 데이터베이스 생성 $ py manage.py migrate # 데이터베이스에 테이블을 생성할 수 있도록 설계도를 작성 $ py manage.py makemigrations polls # 데이터베이스에 실제 테이블을 생성 $ py manage.py migrate # API를 사용하기 위해 $ py manage.py shell # 생성한 모델을 추가 $ from polls.models import Choice, Question # 관리자 생성 # winpty: windows 콘솔과 통신이 가능한 인터페이스를 제공하는 windows software package $ winpty python manage.py createsuperuser 프로젝트와 앱  앱: 특정한 기능을 수행하는 웹 어플리케이션, 다수의 프로젝트에 포함될 수 있다. 프로젝트: 특정 웹 사이트를 위한 앱들과 각 설정들을 한데 묶어놓은 것, 다수의 앱을 포함할 수 있다.  작동 순서  view 내용 입력 뷰를 호출하기 위한 연결 url 생성을 위해 urls.py 파일 생성 최상위 URLconf에서 생성한 urls.py모듈을 바라보게 설정  이때 include()함수는 다른 URLconf드을 참조할 수 있도록 도움 만약 127.0.0.1/polls/이라는 url을 받으면 파싱을 하여 분기, 해당 path인 polls을 잡아내고 연결을 시켜줌 연결된 urls.py에서 path를 통해 view로 연결 view내부의 함수를 통해 response를 클라이언트에게 전달    데이터베이스 django는 기본적으로 SQLite를 사용하도록 구성되어 있으며, 다른 데이터베이스를 사용하고 싶다면 setting.py파일을 수정해서 사용할 수 있다.\nINSTALLED_APPS django를 사용할 때 기본적으로 딸려 오는 앱으로 추가적으로 모델을 사용하기 위해 추가하면 된다.\n admin: 관리용 사이트 auth: 인증시스템 contenttypes: 컨텐츠 타입을 위한 프레임워크 sessions: 세션 프레임워크 messages: 메세징 프레임워크 staticfiles: 정적 파일을 관리하는 프레임워크  모델 부가적인 메타데이터를 가진 데이터베이스의 구조(layout)를 지칭\n 모델은 데이터에 관한 단 하나의, 가장 확실한 진리의 원천\n이 원칙에 따라 데이터 모델을 한곳에서 정의하고, 이것으로부터 자동으로 뭔가를 유도하는 것이 목표\n API 개발자가 필요로하는 데이터를 뽑아낼 수 있도록 하는 함수, 또는 서버에게 데이터베이스에게 데이터를 입력할 수 있도록 하는 함수\nAdmin 페이지 사이트 관리를 위한 관리자 전용 페이지로 django는 자동으로 제공\nssafy class 중요 urls.py: 주소 관리\nviews.py: 페이지 관리\nmodels.py: 데이터베이스 관리\n실행순서  installed_apps: 앱 등록 project/urls.py: path 등록 app/views.py: 요청 수신/반환 함수 작성 templates/index.html: templates 작성  ","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/django-%EA%B8%B0%EB%B3%B8/icon_hu080e9ab032fb83faecb2fd0168b96dc6_15390_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/django-%EA%B8%B0%EB%B3%B8/","title":"Django 기본"},{"content":"HTML  \u0026ldquo;웹 컨텐츠의 의미와 구조를 정의할 때 사용하는 언어\u0026rdquo;\n HTML 기초 Hyper\n 텍스트 등의 정보가 동일 선상에 있는 것이 아니라 다중으로 연결되어 있는 상태  Hyper Text\n 참조(하이퍼링크)를 통해 사용자가 한 문서에서 다른 문서로 즉시 접근 할 수 잇는 텍스트 하이퍼 텍스트가 쓰인 기술등 중 가장 중요한 2가지 (http, html)  Markup Language\n 특정 텍스트에 역할을 부여하는, 따라서 \u0026ldquo;마크업을 한다\u0026rdquo; 라고 하는 건 제목이 제목이라하고 본문이 본문이라고 마킹을 하는 것 ex) h1 tag는 단순히 글자가 커지는 것이 아니라 의미론적으로 그 페이지에서 가장 핵심 주제를 의미하는 것  HTML 기본 구조 DOM\n DOM은 문서의 구조화된 표현(structured representation)을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 도움 DOM은 동일한 문서를 표현하고, 저장하고, 조작하는 방법을 제공 웹 페이지의 객체 지향 표현  요소 (Element)\n HTML 요소는 시작 태그와 종료 태그 그리고 태그 사이에 위치한 내용으로 구성  태그(Element, 요소)는 컨텐츠(내용)를 감싸서 그 정보의 성격과 의미를 정의 한다.   내용이 없는 태그들  br, hr, img, input, link, meta   요소는 중첩(nested)될 수 있다.  이러한 중첩들로 하나의 문서를 완성해 나간다. 그리고 항상 열고 닫는 태그 쌍이 잘 맞는지 잘 봐야한다. HTML은 오류를 뿜지 않고 그냥 레이아웃이 깨져버리기 때문에 어떤 면에서는 친절하게 오류 띄워주고 어디 틀렸는지 알려주는 프로그래밍 보다 디버깅이 힘들다.    속성 (Attribute)\n 속성(Attribute)은 태그의 부가적인 정보가 들어온다. 요소는 속성을 가질 수 있으며 요소에 추가적 정보(이미지 파일의 경로, 크기 등)를 제공한다. 요소의 시작 태그에 위치해야 하며 이름과 값의 쌍을 이룬다. 태그와 상관없이 사용 가능한 속성들(html global attribute)도 있다.  시맨틱 태그  브라우저, 검색엔진, 개발자 모두에게 콘텐츠의 의미를 명확히 설명하는 태그\n 장점\n 읽기 쉬워진다. (개발자)  개발자가 의도한 요소의 의미가 명확히 드러나고 있다.이것은 코드의 가독성을 높이고 유지보수를 쉽게 한다.   접근성이 좋아진다. (검색엔진 및 보조기술 → 시력장애용 스크린리더 → 더 나은 경험 제공)  HTML 문서는 html 언어 + 사람이 읽을 수 있는 content의 조합인데, 검색 엔진은 HTML 코드만 잘 읽는다. 그래서 이 검색 엔진이 HTML을 잘 이해하도록 시맨틱 태그 사용이 권장되고, 그러면 검색 엔진도 무슨 내용인지 이해할 수 있게 된다.    시맨틱 웹\n 웹에 존재하는 수많은 웹페이지들에 메타데이터를 부여하여, 기존의 단순한 데이터 집합이었던 웹페이지를 \u0026lsquo;의미\u0026rsquo;와 \u0026lsquo;관련성\u0026rsquo;을 가지는 거대한 데이터베이스로 구축하고자 하는 발상.   참고 문헌 https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Getting_started\nhttps://developer.mozilla.org/ko/docs/Web/HTML/Global_attributes\nhttps://developer.mozilla.org/ko/docs/Glossary/Semantics\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/html%EA%B8%B0%EC%B4%88/html_hu5ae5770cb34043b5079993437294d24c_21751_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/html%EA%B8%B0%EC%B4%88/","title":"HTML기초"},{"content":"Object-Oriented Programming의 약자로 객체지향프로그래밍이다.\n쉽게 말해 주어 동사 형태로 프로그래밍하는 것!\n1. 절차 지향 프로그래밍 물이 위에서 아래로 흐르듯 순차적인 처리가 중요합니다. 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다.\n2. 객체 지향 프로그래밍 실제 세계를 모델링해 소프트웨어를 개발하는 방법입니다. 객체지향 프로그래밍에서는 데이터와 절차를 하나의 덩어리로 묶어서 생각합니다. 마치 컴퓨터 부품을 하나씩 구매해 컴퓨터를 조립하는 것과 같은 방식입니다.\n\r\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/oop/oop_hu77071c61b22f59609cf235d78dd545c9_23490_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/oop/","title":"OOP"},{"content":"SQLD란 무엇일까? 한국데이터산업진흥원에서 주관하는 시험으로, Structured Query Language Developer의 줄임말로 데이터베이스 SQL국가공인 자격증이다😎\n저번주 올해 첫 시험인 03.20(토) 시험을 접수했고 앞으로 3주 가량 남은 상황, 오늘부터 SQLD 공부를 시작한다!!\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/sqld/sql_hubbf8a9fc18cf0c0587203e8c4fcd3fa5_78275_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/sqld/","title":"SQLD"},{"content":"국내 IT기업 기술 블로그 1) Naver D2\n· 국내 최대 포털사이트 네이버의 기술블로그 Naver D2입니다. NAVER 개발자들이 직접 정리한 실전 개발 경험과 지식, 주요 개발자 행사 소식과 후기를 업로드합니다.\n2) kakao Tech\n· 카카오의 기술 블로그로, 카카오 서비스를 만드는 개발자들의 실제 개발 사례를 중심으로 기술과 노하우를 전달합니다. 이벤트와 오픈소스, 채용 정보도 확인할 수 있습니다.\n3) 쿠팡 기술블로그\n· 국내 온라인 쇼핑 사이트 쿠팡의 기술블로그입니다. 쿠팡 글로벌 개발팀이 쿠팡을 만들고 진화시키면서 배운 점과 얻은 교훈을 비롯해 다양한 테크 관련 이야기를 전달합니다.\n4) WATCHA 팀 블로그\n· 국내 OTT 서비스의 대표 주자 왓챠의 팀 블로그입니다. 개발, 테크, 기술이 가장 메인 주제입니다. 종종 왓챠팀의 문화, 브랜딩 소식을 올리기도 합니다.\n5) 당근마켓 기술 블로그\n· 2020년 6월 누적 2천만 다운로드, 월 순 방문자수 800만 명을 돌파한 중고거래 앱 서비스 당근마켓의 팀 블로그입니다. 개발, 테크 관련 콘텐츠가 주를 이룹니다.\n6) 우아한형제들 기술 블로그\n· 국내 대표 푸드 테크 서비스 배달의민족을 운영하는 우아한형제들의 기술 블로그입니다. 우아한 형제들의 대표적 개발자 양성 프로그램인 우아한 테크코스의 후기 포스팅이 올라오기도 합니다.\n7) LINE Engineering\n· 글로벌 메신저 서비스 LINE이 운영하는 기술 블로그입니다. 블로그 포스팅과 더불어 오픈소스와 채용정보도 확인하실 수 있습니다.\n8) 마켓컬리 Tech Blog\n· 코로나19 사태로 인해 최근 가장 주목 받는 기업 중 하나가 된 푸드 테크 기업 마켓컬리의 기술 블로그입니다.\n9) 뱅크샐러드 기술 블로그\n· 금융플랫폼 서비스 뱅크샐러드의 공식 블로그입니다. 기술, 개발, 테크 관련 콘텐츠가 주를 이루고 있습니다.\n10) NHN 기술블로그 TOAST Meetup!\n· 종합 IT 기업 NHN의 기술 블로그입니다. 블로그 메인화면에서 기술을 공유하고 함께 성장해가는 개발 문화를 추구한다고 밝히고 있습니다.\n11) 강남언니 공식 블로그\n· 미용 의료 분야의 Tech 기업 강남언니의 공식 블로그입니다. 기술, 테크 주제의 콘텐츠와 함께 브랜드, 조직문화에 대해서도 공유합니다.\n12) Delivery Tech Korea\n· 푸드 테크 기업 딜리버리코리아의 기술 블로그입니다. 요기요\u0026amp;배달통 서비스 개발 및 협업 방식과 문화에 대한 포스팅을 업로드합니다.\n13) HYPER CONNECT 기술 블로그\n· 실시간 영상채팅 서비스 아자르(Azar)를 제작한 비디오 및 인공지능 기술 기반의 영상 기술 기업 하이퍼커넥트의 기술 블로그입니다.\n14) Spoqa 기술 블로그\n· 매장 마케팅 솔루션 도도 포인트를 서비스하는 스포카의 기술 블로그입니다. 블로그 소개에서 건강한 오픈소스 커뮤니티 형성을 위해 배우고 개선한 것들을 오픈소스로 공개한다고 말합니다.\n15) 쏘카 기술블로그\n· 그린카와 더불어 국내 대표 카셰어링 서비스 쏘카의 기술 블로그입니다.\n16) 리디 Tech blog\n· 리디북스를 비롯해, 리디셀렉트, 리디페이퍼, 아웃스탠딩 등의 콘텐츠 플랫폼 서비스를 제공하는 리디코퍼레이션의 기술 블로그입니다.\n17) 이스트소프트 AI PLUS TECH\n· 알집, 알약으로 익숙한 이스트소프트의 기술 블로그입니다. 주로 AI 주제의 콘텐츠를 포스팅합니다.\n18) 플랫팜 팀 블로그\n· 이모티콘 콘텐츠 플랫폼이자 메신저 기업을 대상으로 하는 B2B 솔루션 Mojitok을 서비스하는 플랫팜의 팀 블로그입니다.\n19) 레진 기술 블로그\n· 웹툰 서비스인 레진코믹스를 제작하는 레진엔터테인먼트가 운영하는 기술 블로그입니다.\n20) 플라네타리움 엔지니어링 스낵\n· 게임에 특화된 오픈 소스 P2P 라이브러리 Libplanet과, 중앙 서버 없는 온라인 게임 나인 크로니클을 제작하는 테크 기업, 플라네타리움의 기술 블로그입니다.\n국내 기술 콘텐츠 플랫폼 1) Velog\n· 개인 기술 블로그와 최신 콘텐츠를 찾을 수 있는, 기술 블로그 콘텐츠 큐레이션 플랫폼입니다.\n2) GeekNews\n· 개발, 기술, IT 소식, 스타트업 등을 전하는 뉴스 큐레이션 플랫폼입니다. 해외 기술 동향과 관련된 소식을 확인하실 수 있습니다.\n3) 개발자스럽다\n· 개발자를 위한 주요 소식과 뉴스레터를 공유하는 사이트입니다.\n4) 44BITS\n· 당근마켓 개발자를 비롯해, 총 5명의 개발자가 프로그래밍과 클라우드를 주요 주제로 운영하는 기술 블로그입니다.\n5) 프로그래머스\n· 기술 중심 개발자 채용 플랫폼입니다. 기술 블로그는 아니지만 개발, IT 직군의 주요 채용 공고를 확인하실 수 있습니다.\n해외 IT 기업 기술 블로그 1) Facebook Engineering\n· 세계 최대 소셜 미디어 페이스북의 기술 블로그입니다. 인스타그램도 검색하면 기술 블로그는 나오지만 2019년 이후로 업데이트가 되지 않고 있습니다.\n2) Amazon Alexa\n· 세계 최대 이커머스 플랫폼 아마존의 기술 블로그입니다. Alexa는 아마존이 개발한 인공지능 플랫폼의 이름입니다.\n3) Apple Developer\n· 앱스토어 내 앱 제작 등 애플 관련 서비스를 사용해야 하는 개발자들을 위해 만들어진 애플의 기술 블로그입니다. 애플 관련 주요 소식을 전달하는 뉴스룸에 더 가깝습니다.\n4) THE NETFLIX TECH BLOG\n· 세계적인 동영상 스트리밍 서비스 기업 넷플릭스의 기술 블로그입니다.\n5) Google Devlopers\n· 세계 최대 테크 기업 구글의 기술 블로그입니다. 구글과 관련한 기술, 뉴스, 업데이트 내용을 주로 다룹니다.\n6) Microsoft Tech Community\n· 세계 최대 소프트웨어 기업 마이크로소프트도 기술 블로그를 운영하고 있습니다. 개발자들끼리 궁금한 점을 묻고 답할 수 있는 테크 커뮤니티도 잘 형성되어 있습니다.\n7) Linkedin Engineering\n· 채용 중심의 소셜 미디어 링크드인의 기술 블로그입니다.\n8) Slack Engineering\n· 세계 대 협업 메신저인 슬랙의 기술 블로그입니다.\n9) Spotify Engineering\n· 머지 않은 미래에 한국 출시가 예상되는, 음원 스트리밍 플랫폼 스포티파이의 기술 블로그입니다.\n10) PayPal Engineering Blog\n· 미국의 간편 결제 서비스 페이팔의 기술 블로그입니다.\n11) ebay Tech Blog\n· 국내에서는 G마켓, 옥션, G9를 서비스 중인 세계적인 오픈마켓 이베이의 기술 블로그입니다.\n12) Twitter Engineering\n· 페이스북과 더불어 대표적 소셜 미디어 중 하나인 트위터의 기술 블로그입니다.\n13) RIOT GAMES TECHBLOG\n· 롤이라는 이름으로 널리 알려진 인기 게임, 리그 오브 레전드를 서비스하는 라이엇 게임즈의 기술 블로그입니다.\n14) Figma Blog Engineering\n· 스케치의 뒤를 이어 최근 많은 주목을 받고 있는 웹/앱 디자인 협업툴 피그마의 기술 블로그입니다.\n15) Airbnb Engineering \u0026amp; Data Science\n· 숙박 공유 플랫폼 에어비앤비의 기술 블로그입니다. 블로그 이름에서 알 수 있든 데이터 사이언스 관련 포스팅이 많습니다.\n16) Zoom Developer Blog\n· 코로나19 사태의 수혜를 받은 대표적 기업, 화상회의 플랫폼 줌의 기술 블로그입니다.\n17) Pinterest Engineering\n· 디자이너와 그림에 관심 있는 분들의 필수 사이트, 핀터레스트의 기술 블로그입니다.\n18) Uber Engineering\n· 차량 공유 서비스 (Rider Sharing) 우버의 기술 블로그입니다.\n19) Google Play Apps \u0026amp; Games\n· 구글 플레이 관련 기술적 팁, 트렌드, 지식을 제공하는 구글 플레이 기술 블로그입니다.\n20) Drpbox Tech\n· 웹 기반 파일 공유 서비스 드롭박스의 기술 블로그입니다.\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/%EA%B8%B0%EC%88%A0%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%86%8C%EA%B0%9C/tech_hu9335188f5464ae1366b02b4610e0ffc3_286791_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/%EA%B8%B0%EC%88%A0%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%86%8C%EA%B0%9C/","title":"기술블로그 소개"},{"content":"Algorithm기본 이론에 대해 알아보자\nBig-Oh Notation 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시\n\r\n배열 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사요하는 자료구조\n완전검색(Brute-force) 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법\n정렬 알고리즘 학습한 정렬 알고리즘의 특성\n\r\n너비우선탐색(BFS) 👉 큐(queue) 매 단계에서 가능한 경우의 수들을 모두 확인하면서 탐색, 트리를 넓히면서 탐색하는 알고리즘\n\r\n깊이우선탐색(DFS) 👉 스택(stack) 여러 경우의 수 중 하나를 선택, 선택 후 가능한 여러 경우의 수 중 하나를 선택\n매 단계에서 가능한 것 중 일단 하나를 선택해 끝을 볼 때까지 확인\n\r\n스택(Stack) 자료를 차곡차곡 쌓는 것\nLast In First Out 👉 후입선출\n\r\n큐(Queue) 줄을 서서 기다리는 것\nFirst In First Out 👉 선입선출\n\r\n구현 순차 DFS - 깊이우선탐색 \r\n\r\n  루트 노드 (시작점) 인 A 를 스택에 넣습니다.\n  A 를 Pop 하면서 Expand 합니다. 즉, A 는 지우고 A 의 자식인 B, C, D 를 스택에 넣습니다.\n  스택의 맨 위에 있는 B 를 Pop and Expand 합니다. 즉, B 는 지우고 B 의 자식인 E 를 스택에 넣습니다.\n  스택의 맨 위에 있는 E 를 Pop and Expand 합니다. 즉, E 는 지우고 E 의 자식인 I, J 를 스택에 넣습니다.\n  스택의 맨 위에 있는 I 를 Pop and Expand 합니다. 이 때, I 는 자식이 없으므로 (끝에 도달했으므로) 스택에 넣을 것이 없습니다.\n  스택의 맨 위에 있는 J 를 Pop and Expand 합니다. 이 때, J 또한 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택의 맨 위에 있는 C 를 Pop and Expand 합니다. 즉, C 는 지우고 C 의 자식인 F 를 스택에 넣습니다.\n  스택의 맨 위에 있는 F 를 Pop and Expand 합니다. 이 때, F 는 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택 맨 위에 있는 D 를 Pop and Expand 합니다. 즉, D 는 지우고 D 의 자식인 H, K 를 스택에 넣습니다.\n  스택의 맨 위에 있는 G 를 Pop and Expand 합니다. 이 때, G 는 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택의 맨 위에 있는 H 를 Pop and Expand 합니다. 이 때, H 는 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택의 맨 위에 있는 K 를 Pop and Expand 합니다. 이 때, K 는 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택이 비었습니다. 이 말은 모든 노드를 탐색했다는 뜻이죠!\n  BFS - 너비우선탐색 \r\n\r\n  루트 노드 (시작점) 인 A 를 큐에 넣습니다.\n  A를 Dequeue 하면서 Expand 합니다. 즉, A 는 지우고 A 의 바로 다음 자식인 B, C, D를 큐의 오른쪽에 넣습니다.\n  큐의 맨 왼쪽에 있는 B 를 Dequeue and Expand 합니다. 즉, B 는 지우고 B 의 바로 다음 자식인 E 만 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 C 를 Dequeue and Expand 합니다. 즉, C 는 지우고 C 의 바로 다음 자식인 F 를 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 D 를 Dequeue and Expand 합니다. 즉, D 는 지우고 C 의 바로 다음 자식인 G, H 를 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 E 를 Dequeue and Expand 합니다. 즉, E 는 지우고 E 의 바로 다음 자식인 I, J 를 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 F 를 Dequeue and Expand 합니다. 이 때, F 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐의 맨 왼쪽에 있는 G 를 Dequeue and Expand 합니다. 이 때, G 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐의 맨 왼쪽에 있는 H 를 Dequeue and Expand 합니다. 즉, H 는 지우고 H 의 바로 다음 자식인 K 를 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 I 를 Dequeue and Expand 합니다. 이 때, I 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐의 맨 왼쪽에 있는 J 를 Dequeue and Expand 합니다. 이 때, J 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐의 맨 왼쪽에 있는 K 를 Dequeue and Expand 합니다. 이 때, K 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐가 비었습니다. 모든 노드를 탐색했다는 뜻이죠!\n ","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%A1%A0/algorithm_hue59cc96f39be3bdd739f8972409a29e2_15547_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%A1%A0/","title":"알고리즘 기초이론"}]