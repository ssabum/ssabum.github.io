[{"content":"🏊‍♂️ 혼자 뭐하니?!  혼자뭐하니는 SSAFY 공통프로젝트에서 진행했던 팀프로젝트로, 원하는 운동종목의 그룹을 찾아 함께 즐겁게 운동을 하는 SNS 서비스이다.\n 1. 프로젝트 소개 매번 새해가 밝으면 우리 모두 하는 다짐, 꾸준한 운동!!! 하지만 이를 이루어나가기는 쉽지 않습니다. 그래서 준비한 서비스 🎉혼자뭐하니🎉\n혼자뭐하니는 사용자가 원하는 운동종목으로 팀을 찾거나 만들어서 팀원들과 함께 소통하며 운동을 하는 서비스입니다. 또한 그룹 챌린지와 공통 미션들을 통해 보다 즐겁고 꾸준하게 운동을 지속할 수 있으며 결재시스템과 추천시스템을 통해 차별화된 서비스를 제공합니다.\n팀 목록 페이지 이미지를 클릭하면 움짤로 볼 수 있습니다 👇\n\r\n그룹 페이지 이미지를 클릭하면 움짤로 볼 수 있습니다 👇\n\r\n2. 맡은 역할 \u0026amp; 후기 해당 프로젝트에서 프론트엔드를 맡아서 진행하였습니다.👨‍💻💦\n다수의 인원들과 웹개발 협업 프로젝트를 진행하면서 제대로된 프론트엔드 개발을 경험할 수 있었고 협업 프로젝트 관리 서비스인 JIRA와 Git을 본격적으로 사용할 수 있었던 소중한 경험이었습니다. 다음 프로젝트는 때는 백엔드도 경험해 볼 수 있으면 좋겠다 생각했습니다.\n또한 결과물이 최우수 작품으로 선정되어 보다 뿌듯함을 느낄 수 있었습니다!! 팀원들 쵝오!!😎\n3. 관련 링크  깃허브 노션  ","date":"2021-09-04T00:00:00Z","image":"https://ssabum.github.io/content/%ED%98%BC%EC%9E%90%EB%AD%90%ED%95%98%EB%8B%88/main_hu704ed9b9a384d8603f896254c41916b6_52714_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%ED%98%BC%EC%9E%90%EB%AD%90%ED%95%98%EB%8B%88/","title":"혼자뭐하니"},{"content":"🛠 버전 관리 시스템 어느 정도 규모가 있는 소프트웨어를 개발하다보면 소스코드의 버전 관리 시스템(Version Control System)을 사용하게 된다. 비교적 오래된 프로젝트의 경우 SVN(Subversion)이나 CVS(Concurrent Versions System), 심지어 파일 서버에 소스코드를 보관하는 형태로 코드를 관리하는 경우도 있다. 하지만 최근에는 DVCS(Distributed Concurrent Versions System) 인 git으로 어느정도 통일되는 추세이다. git이 갖는 큰 장점중 하나는 효율적인 브랜치 관리다. 쉽게 브랜치를 생성하여 기능을 추가하거나 버그를 수정할 수 있고, 만들어진 브랜치를 손쉽게 병합 할 수 있다.\n1. git-flow  git-flow는 Vincent Driessen의 \u0026ldquo;A successful git branching model\u0026quot;에서 제안한 브랜치 모델을 쉽게 사용할 수 있도록 몇개의 명령으로 구현해 놓은 git의 확장이다.\n \r\nVincent Driessen의 브랜칭 모델에는 5개의 브랜치가 사용된다.\n1) master master 브랜치는 배포될 안정적인 버전의 소스코드를 포함하고 있다. master 브랜치의 HEAD는 최신 배포판의 소스 코드 버전이 있다. master 브랜치에는 지난 배포 버전이 태그(tag) 형태로 관리된다. master 브랜치에는 배포해도 될 만큼 안정성이 검증된 코드들이 병합된다.\n2) develop develop 브랜치에는 끊임 없이 새로운 기능들과 버그 수정들이 병합된다. 새로운 기능을 개발하는 여러 개발자들은 develop 브랜치를 기준으로 feature 브랜치를 생성해서 작업을 한다음 다시 develop 브랜치로 내용을 병합한다. 따라서 develop 브랜치에는 끊임없이 새로운 내용들이 병합된다.\n3) feature 새로운 기능 개발을 위해 생성하는 브랜치다. develop 브랜치를 기반으로 생성되며 기능 개발이 완료된 다음 다시 develop 브랜치로 병합된다.\n4) release 새로운 릴리즈를 생성하기 위해 만들어지는 브랜치다. develop 브랜치를 기반으로 생성되며 develop 브랜치와 master 브랜치로 병합된다. 새로운 릴리즈를 생성하기 위해 다음번 릴리즈에 포함될 기능셋들을 확정지어야 하며, 해당 기능들이 개발되어 develop 브랜치로 병합되면 그 이후 release 브랜치를 생성하여 릴리즈를 준비한다.\n릴리즈 브랜치에는 릴리즈 준비 과정에서 발견된 버그 수정 사항 같은 패치들만 적용이 되며, 메이저 기능들은 추가되지 않는다.\n이 후 릴리즈 브랜치의 코드가 안정적이라고 판단되면 master 브랜치에 병합되고 릴리즈에 해당하는 태그가 생성된다. 또 한 릴리즈 브랜치에 수정된 버그들은 develop 브랜치로도 다시 병합된다.\n5) hotfix 정기적인 릴리즈 이외에 긴급하게 수행되어야 할 버그 수정을 반영하기 위해 생성되는 브랜치다. 정기적인 릴리즈 계획과 별도로 치명적인 버그가 발견되어 1분 1초라도 빨리 패치가 되어야 할 경우 이 브랜치를 사용한다.\nhotfix 브랜치는 master 브랜치를 기반으로 생성된다. 생성된 hotfix 브랜치에 긴급 패치들이 반영된다. 이 후 다시 master 브랜치로 병합되고 태그를 생성한다. 마찬가지로 수정 사항은 develop 브랜치로도 병합되어 긴급 수정 사항이 이후 릴리즈에도 반영되도록 한다.\n2. git-flow 설치  git-flow는 git의 확장이다. 즉 git-flow를 사용하기 위해서 우선 git이 설치되어 있어야 한다. git은 패키지 매니저를 이용해 쉽게 설치할 수 있다.\n 우선 우분투 같은 데비안 계열의 리눅스는 apt-get을 이용해서 설치할 수 있다.\n$ apt-get install git-core $ apt-get install git-flow 맥의 경우 HomeBrew를 이용해 쉽게 설치가 가능하다.\n$ brew install git $ echo \u0026#34;export PATH=/usr/local/bin:$PATH\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile $ brew install git-flow-avh 윈도우의 경우 Cygwin을 이용해 쉽게 설치가 가능하다.\n$ wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash 3. git-flow 사용법 1) init  git-flow를 사용하기 위해서는 초기화가 필요하다. 마치 git init을 실행해서 로컬 저장소(Repository)를 초기화하는 것처럼 git flow init을 통해서 브랜치들을 생성해줘야한다.\n 브랜치 관리를 할 로컬 저장소 디렉토리에서 다음 명령을 실행한다.\n$ git flow init 그러면 Vincent Driessen이 제안했던 여러 브랜치들의 이름을 지정할 수 있다. 그냥 엔터키만 누르면 기본값으로 이름이 정해진다.\nHow to name your supporting branch prefixes? Feature branches? [feature/] Bugfix branches? [bugfix/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] Hooks and filters directory? [/Users/user/workspace/test/.git/hooks] 위 명령을 실행하면 기본값으로 브랜치들이 생성된다.\n  master : 사용자에게 배포되는 Stable 브랜치\n  develop : 다음 릴리즈를 위해 기능들을 모으는 최신 브랜치\n  feature : 특정 기능 개발을 위한 브랜치\n   release : 릴리즈를 위해 버그 픽스(Bug fix)를 모으는 브랜치    hotfix : 긴급 버그 픽스를 위한 브랜치\n  support : 버전 호환성 문제를 위한 브랜치\n  Version tag prefix는 master 브랜치로 릴리즈 버전이 병합될 때 생성되는 태그(Tag)의 프리픽스(Prefix)를 설정할 수 있는 선택 항목이다.\nHooks and filters directory 는 git hook을 위한 디렉토리다. git 역시 다른 버전 관리 시스템처럼 어떤 이벤트가생겼을 때 자동으로 특정 스크립트를 실행하도록 할 수 있다. 예를 들어 git commit을 수행했을 때 자동으로 git push를 하도록 post-commit 파일에 훅을 저장해 놓을 수 있다. 다양한 활용 방안이 있으므로 잘 사용하면 된다.\n2) feature 특정 기능을 개발하기 위한 개발 브랜치(feature branch)를 다루기 위한 명령이다. 새로운 개발 브랜치를 생성하기 위해서는 다음 명령을 실행한다.\n$ git flow feature start \u0026lt;feature name\u0026gt; 이 명령을 수행하면 develop 브랜치를 기반으로 새로운 기능 개발 브랜치가 생성되며 자동으로 해당 브랜치로 checkout 된다. 생성된 브랜치는 feature/의 이름을 갖는다. (혹은 git flow init에서 feature 브랜치 이름으로 입력한 문자열이 feature 대신 들어간다)\n이제 새로 생성된 기능 개발 브랜치에 기능 개발 작업을 하고, 커밋을 하면서 작업을 진행하면된다.\n기능 개발 작업이 끝나서 마무리를 할 때에는 다음 명령을 실행한다.\n$ git flow feature finish \u0026lt;feature name\u0026gt; 이 명령을 수행하면, git-flow는 develop 브랜치로 checkout 한 다음, feature branch의 변경사항을 merge 한다. 그리고 feature branch를 삭제한다.\n만약 github 같은 플랫폼을 통해서 여러 개발자들과 함께 작업을 하려는 경우 원격 저장소(remote repository)에 기능개발 브랜치를 push 해야한다. 다음 명령을 수행하면 된다.\n$ git flow feature publish \u0026lt;feature name\u0026gt; 반대로 원격 저장소에서 feature branch를 가져오려면 다음 명령을 수행하면 된다.\n$ git flow feature pull origin \u0026lt;feature name\u0026gt; 3) release 릴리즈를 위한 브랜치를 생성하기 위해서 다음 명령을 실행하면 된다.\n$ git flow release start \u0026lt;version\u0026gt; 이 명령을 실행하면 develop 브랜치를 기반으로 release/version 이라는 브랜치가 생성된다. 마찬가지로 git flow init 수행시 release 브랜치 이름으로 다른 문자열을 입력했으면 그 문자열이 release 대신 설정된다.\n이제 이 브랜치에 버그 수정 사항들을 추가하면 된다.\nfeature와 마찬가지로 다른 사용자와 협업을 위해 원격 저장소로 push 할 수 있다.\n$ git flow release publish \u0026lt;version\u0026gt; 이 명령을 수행하면 origin으로 설정된 원격 저장소로 변경사항을 Push 한다.\n반대로 원격 저장소에서 변경사항을 가져오려면 다음 명령을 수행하면 된다.\n$ git flow release track \u0026lt;version\u0026gt; 릴리즈 준비 작업이 마무리되었으면 다음 명령을 이용해서 릴리즈를 마무리한다.\n$ git flow release finish \u0026lt;version\u0026gt;  이 명령을 수행하면\n  release 브랜치를 master 브랜치에 병합(merge) 하고\n  release 버전을 태그로 생성한다. 이 때, git flow init 에서 명시한 Version tag prefix 문자열이 release버전 앞에 추가되어 태그로 생성된다.\n  release 브랜치를 develop 브랜치에 병합한다.\n  release 브랜치를 삭제한다.\n  이제 새로운 릴리즈가 포함된 master 브랜치를 원격 저장소에 태그들과 함께 push하면 된다.\n $ git push --tags 4) hot fix 긴급 패치를 위한 Hot Fix 브랜치 생성도 릴리즈 브랜치와 비슷하게 사용할 수 있다.\n$ git flow hotfix start \u0026lt;version\u0026gt; 위 명령을 수행하면 새로운 핫픽스 브랜치가 생성된다.\n이제 긴급하게 패치할 버그 수정사항들을 이 브랜치에 반영한 다음 finish 명령으로 핫 픽스를 마무리한다.\n$ git flow hotfix finish \u0026lt;version\u0026gt;  이 명령을 수행하면\n  hotfix 브랜치를 master 브랜치로 병합한다\n  hotfix 버전을 태그로 생성한다. 마찬가지로 git flow init 에서 명시한 Version tag prefix 문자열이 hotfix 버전 앞에 추가되어 태그로 생성된다.\n  hotfix 브랜치를 develop 브랜치에 병합한다\n  hotfix 브랜치를 삭제한다.\n   ","date":"2021-08-30T00:00:00Z","image":"https://ssabum.github.io/content/gitgit-flow/git_huc125b13fde7b496f851c2a47c8ae5c32_28812_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/gitgit-flow/","title":"[Git]git-flow"},{"content":"MySQL👨‍💻  MySQL은 가장 널리 사용되고 있는 관계형 데이터베이스 관리 시스템(RDBMS: Relational DBMS)이다!\n 1. SQL문 기초  SHOW DATABASES : 서버에 있는 DB보여주기 USE : 특정 DB 사용 SHOW TABLE, SHOW TABLE STATUS : 해당 DB의 테이블 이름보기 / 정보 조회 DESCRIBE (DESC) : 특정 테이블에 무슨 열이 있는지 확인 SELECT : 원하는 결과 출력하기 WHERE : 출력을 위한 조건 BETWEEN : 조건이 특정값 사이에 있을 때 IN : 안에 있는지 없는지 LIKE : _ 한글자 % / 글자수 제한 X Sub Query : =로 연결한 서브쿼리 ANY(SOME) : 하나라도 만족하면 ALL : 모두 만족 ORDER BY : 정렬 AES 오름차순 / DESC 내림차순 DISTINCT : 중복제거 LIMIT : 출력할 결과물 개수제한 GROUP BY : 그룹으로 묶어서 집계함수와 함께 사용 HAVING : 집계함수에 대한 조건 ROLLUP : GROUP BY절에서 WITH ROLLUP으로 사용하며 총합 또는 중간합계 JOIN : 여러 테이블을 합칠때 사용, ON을 통해 조건을 제시  2. MySQL 내장함수  LENGTH() : 문자열 길이 반환 CONCAT() : 전달받은 문자열을 모두 결합하여 하나의 문자열로 반환, 하나라도 NULL값이 있으면 NULL을 반환 LOCATE() : 찾는 문자열이 처음으로 나타나는 위치를 찾아서 반환, 없으면 0을 반환하며, MySQL에서는 문자열의 시작 인덱스를 1로 계산 LEFT(), RIGHT() : 문자열의 왼쪽 / 오른쪽에서 부터 지정한 개수만큼 문자 반환 LOWER(), UPPER() : 소문자 / 대문자 변환하여 반환 REPLACE() : 문자열에서 특정 문자열을 다른 문자열로 변환하여 반환 TRIM() : 공백제거 / LEADING : 앞에 존재하면 제거 / TRAILING : 뒤에 존재하면 제거 FORMAT() : 숫자타입의 데이터를 세자리마다 쉼표로 구분 FLOOR(), CEIL(), ROUND() : 내림 / 올림 / 반올리 SQRT(), POW(), EXP(), LOG() : 양의 제곱근 / 첫째 인수를 밑, 둘째 인수를 지수로 거듭제곱 / 자연상수의 거듭제곱 / 자연로그 SIN(), COS(), TAN() : 사인 / 코사인 / 탄젠트 ABS(), RAND() : 절대값 / 0~1사이의 하나의 실수를 무작위로 생성 NOW(), CURDATE(), CURTIME() : 현재 날짜와 시간 / 현재 날짜 / 현재 시간 DATE(), MONTH(), DAY(), HOUR(), MINUTE(), SECOND() : 전달받은 값에 대한 날짜 정보 / 월 정보 / 일 정보 / 시간 정보 / 분 정보 / 초 정보 MONTHNAME(), DAYNAME() : 월에 해당하는 이름을 반환 / 요일에 해당하는 이름을 반환 DAYOFWEEK(), DAYOFMONTH, DAYOFYEAR() : 일자가 해당 주에서 몇번째 날짜인지(일요일=1, 토요일=7) / 일자가 해당 월에서 몇번째 날짜인지(0~31) / 일자가 해당 연도에서 몇번째 날인지(1~366) DATE_FORMAT() : 전달받은 형식에 맞춰 날짜와 시간 정보를 문자열로 반환  3. SQL 고급  CREATE TABLE AS SELECT : 테이블을 복사하여 생성 CREATE DATABASE : DB 생성 CREATE TABLE : 테이블 생성 ALTER TABLE (ADD, MODIFY, DROP) : 테이블 컬럼 수정 작업 추가 / 타입 수정 / 삭제  1. INDEX  원하는 데이터를 빠르게 찾기 위해 사용\n  CREATE INDEX, ADD INDEX : ON을 사용해 특정 테이블에 인덱스 생성 / 추가 SHOW INDEX : 인덱스 정보 보기 CREATE UNIQUE INDEX : 중복값을 허용하지 않는 인덱스 생성 FULLTEXT INDEX : 일반 인덱스와 다르게 매우 빠르게 테이블의 모든 텍스트 컬럼을 검색 INDEX 삭제 (ALTER) : 인덱스 삭제 DROP INDEX : ON을 사용해 특정 테이블의 인덱스 삭제  2. VIEW  DB에 존재하는 일종의 가상 테이블\n  CREATE VIEW : AS를 이용해 해당 컬럼을 가지는 뷰 생성 ALTER VIEW : 뷰 수정 DROP VIEW : 뷰 삭제  3. 데이터 추가  INSERT : INTO를 사용하여 데이터 추가 INSERT INTO SELECT : 다른 테이블에 있는 데이터를 추가 UPDATE : SET을 사용하여 데이터를 수정 DELETE : 데이터 삭제, 테이블 용량 자체는 줄지 않는다 TRUNCATE : 데이터 삭제, 복구 불가 DROP TABLE : 테이블 삭제 DROP DATABASE : DB 삭제  4. 문제 풀이 프로그래머스 SQL 고득점 Kit 문제\n추가 내용 1. SET변수 활용 SET을 이용하면 변수처럼 활용할 수 있다. 단, SET 이외의 명령문에서는 =가 비교연산자로 취급되므로 SELECT로 변수를 선언하고 값을 대입할 때는 :=를 사용해야 한다.\n-- 0~24시까지 시간별로 데이터를 카운트 할 때 -- 데이터에 없는 시간까지 출력하기 위해서 SET변수 활용 SET @HOUR = -1; SELECT (@HOUR := @HOUR + 1) AS \u0026#39;HOUR\u0026#39;, (SELECT COUNT(*) FROM ANIMAL_OUTS WHERE HOUR(DATETIME) = @HOUR) AS \u0026#39;COUNT\u0026#39; FROM ANIMAL_OUTS WHERE @HOUR \u0026lt; 23 2. OUTER JOIN \r\n3. DATA_FORMAT \r\n","date":"2021-08-14T00:00:00Z","image":"https://ssabum.github.io/content/sqlmysql/mysql_hu07b159bcfc8e2c4da17d54f1731b5ada_39031_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/sqlmysql/","title":"[SQL]MySQL"},{"content":"알고리즘  순서대로 정의된 절차\n모든 동작은 명확하게 정의되어 실행 가능해야 한다.\n일정한 시간 안에 반드시 원하는 결과가 나와야 한다.\n 1. 알고리즘 구조  순차적 구조 분기 구조 반복 구조 점프 구조  2. 알고리즘 기술 방법  플로우 차트 프로그램 언어 코드 pseudocode  그래프  정점vertex과 간선edge들의 집합으로 이루어진 집합\n 1. 오일러 그래프  오일러 경로 : 그래프의 모든 연결선을 한번만 방문하는 경로 오릴러 순환 : 시작점과 끝점이 동일한 오일러 경로 오일러 그래프 : 오일러 순환이 존재하는 그래프 차수 : 정점에 접합된 연결선의 수  2. 오일러 경로를 갖기 위한 필요충분 조건 2개 이상의 정점을 갖는 루프가 없는 연결그래프에서 홀수 차수를 갖는 정점이 하나도 없거나 오직 두개만 존재해야 한다. 특히 모든 정점이 짝수 차수를 자기면 오일러 순환이 존재하고, 이 그래프는 오일러 그래프이다.\n3. 해밀턴 경로  그래프에서 모든 정점을 정확히 한번만 지나는 경로 해밀턴 순환 : 시작점과 끝점이 같은 해밀턴 경로 시간복잡도 : O(x^n)  4. 그리드 알고리즘 결정을 할 때마다 최종 결과에 관계없이 그 순간에서 최선의 선택을 진행, 하지만 최종의 결과가 최적이라는 보장은 없다.\n신장트리  순환이 존재하지 않는 부분 그래프\n 1. 최소 신장트리 알고리즘 Prim 알고리즘 \r\n  가중그래프에서 가중치의 합을 최소로 하는 신장트리\n  그리디 알고리즘 방식을 사용하지만 그래프에서 항상 최적의 결과를 보장\n  간선의 개숭에 비해 정점의 개수가 적은 경우 유리\n  시간복잡도 : O(V^2) / O(ElogV)\n  Kruskal 알고리즘 \r\n 가장 고려할 점은 계산할 때 순환을 만들지 않는 것 정점의 개수에 비해 간선의 개수가 적은 경우 유리 시간복잡도 : O(ElogV)  2. 최단 경로 알고리즘 Dijkstra 알고리즘  하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 탐색 방향, 비방향 그래프 모두 적용 가중치값이 음수가 아니어야 한다. 시간복잡도 : O(ElogV)  \r\n\r\nBellman-ford 알고리즘  하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 탐색 방향, 비방향 그래프 모두 적용 가중치가 음수일 때도 적용, 하지만 순환을 구성하는 연결선의 가중치는 양수여야 한다. 라우팅 프로토콜에 사용 시간복잡도 : O(VE) / O(E^2)  \r\n\r\n\r\n","date":"2021-07-25T00:00:00Z","image":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99-3rd/math_hu8d027683bf45a66bb5fe4bb6f0f36a3b_183689_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99-3rd/","title":"[CS]이산수학 3rd"},{"content":"언어  기본요소들의 집합으로 만들어지는 문자열\n  알파벳 : 기호들의 집합 문법 : 알파벳으로부터 문장들의 집합을 형성하는 규칙이 존재 의미론 : 규칙에 합당하게 만들어진 문장들이 어떤 의미를 갖는지 결정  1. 형식언어 구성요소 : 심벌, 알파벳, 문자열, 공문자열\n2. 구-구문 문법 G = (V, T, S, P) 👉 V : 기호의 집합 T : 단말기호 S : 시작기호 P : 생성규칙\n\r\n3. 정규식 \r\n오토마타 1. 유한 상태기계  상태가 유한개 존재하는 기계\n \r\n 출력이 있는 유한 상태기계  출력이 상태의 추이함수에 의해 결정 출력이 상태에 의해 결정    \r\n 출력이 없는 유한 상태기계  \r\n 튜닝머신 등등  2. 결정 오토마타 입력값에 대해서 전이되는 상태가 정확하게 결정\n3. 비결정 오토마타 입력값에 대해서 상태 전이가 다수 존재, 입력값에 대해서 상태 전이가 발생하지 않을 수 있다.\n셈  어떤 사건이 발생할 수 있는 경우의 수\n 1. 곱의 법칙 사건들이 동시에 발생할 경우\n2. 합의 법칙 사건들이 동시에 발생할 수 없는 경우\n포함배제의 원리 합의 법칙을 적용할때 중복되어 계산된 경우의 수를 고려\n","date":"2021-07-25T00:00:00Z","image":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99-4th/math_hu8d027683bf45a66bb5fe4bb6f0f36a3b_183689_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99-4th/","title":"[CS]이산수학 4th"},{"content":"이산수학(Discrete mathematics)  불연속적인 숫자를 다루는 수학\n컴퓨터를 위한 수학, 참과 거짓으로 판단할 수 있으며 자료구조 또는 알고리즘의 베이스, 논리적 사고, 컴퓨팅 사고력 향상\n 1. 명제  참이나 거짓으로 진리를 구분할 수 있는 문장 명제는 0또는 1만을 가지는 컴퓨터 메모리처럼 항상 참과 거짓 중 하나의 값만을 가짐 여러 개의 명제를 조합할 수 있음  2. 연산자 명제를 다루기 위한 도구\n\r\n3. 명제의 역, 이, 대우  조건 명제에서 사용되는 역, 이, 대우는 하나의 명제를 변형하여 표현 증명하기 어려운 명제는 대우를 이용하여 증명할 수 있다 대우가 참인 경우 본 명제 또한 참이라는 특성을 가지고 있다  \r\n4. 진리표 \r\n5. 동치관계  동치란 논리적으로 일치한다는 의미 흔히 동치는 같은 의미를 가진 더 쉬운 명제를 발견하는 데 사용 동치법칙에는 다양한 종류가 존재  \r\n","date":"2021-07-13T00:00:00Z","image":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99/math_hu8d027683bf45a66bb5fe4bb6f0f36a3b_183689_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99/","title":"[CS]이산수학"},{"content":"명제  명제 = 주어 + 술어\n 1. 명제 판별법  사실명제 : 관찰, 측정, 실험 논리명제 : 수학, 논리학  2. 복합명제(compound proposition) 단순명제의 조합으로 이루어진 명제\n추론(Reasoning)  참으로 알고 있는 명제로부터 새로운 참인 명제를 찾는 과정\n  연역법 : p → q, p가 참이므로 q가 참 귀납법 : 개별적 사실을 말하는 명제로부터 일반적인 결론을 도출 성급한 일반화 : 몇 개의 사례나 경험으로 전체 또는 전체의 속성을 단정짓고 판단  부울  어떤 명제의 참과 거짓을 이진수에 대응시켜 명제와 명제간의 관계를 수학적으로 표현\n  부울변수 : 집합 {0, 1}의 원소 값만을 갖는 변수 부울함수 : 0또는 1의 입력값들에 대하여 0또는 1의 출력값을 갖는 함수 쌍대성의 원리(Duality Principle) : 부울식으로 표현된 함수들 사이에 항등성이 유지되면 이들의 쌍대도 항등성을 유지  \r\n논리회로 1. 논리회로설계  문제 → 입력과 출력 정의 부울 함수 → 부울식 → 논리회로\n \r\n\r\n2. 부울식의 최소화 카르노맵에서 하나의 변수만이 다른 최소항들은 서로 인접한다고 한다, 이때 인접한 칸이 1일 때 인접된 칸을 나타내는 최소항은 변수 중에서 공통된 변수 하나만으로 나타낼 수 있다.\n 카르노맵 : 부울함수의 간단한 논리합 형식을 찾아내는 방법  \r\n예제 \r\n","date":"2021-07-13T00:00:00Z","image":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99-2nd/math_hu8d027683bf45a66bb5fe4bb6f0f36a3b_183689_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/cs%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99-2nd/","title":"[CS]이산수학 2nd"},{"content":"1. 자바개발환경 설치 JDK는 java development kit의 줄임말로 개발하는데 필요한 라이브러리와 플랫폼이 포함\n\r\n byte code는 exe파일이 아니기 때문에 바로 실행이 불가능하므로 JVM이 필요 따라서 실행파일이 메모리에 로딩되고 운영체제 플랫폼에 맞게 리소스를 재컴파일 실행 어떤 운영체제에서 작동할지 모르기 때문에 JVM이 각 OS에 맞게 재컴파일을 통해 실행 가상머신에 따라 실행하므로 속도가 비교적 느리고 JVM이 필요하기 때문에 JRE(실행환경) 필요  // 출력문 public class TPC01 { public static void main(String[] args) { // syso + Ctrl + spaceBar \tSystem.out.println(\u0026#34;Hello Java\u0026#34;); } } 2. 프로그래밍 3대 요소 1. 변수, 자료형, 할당 \r\n할당은 변수에 값을 대입하는 것으로 변수에 값, 수식, 메서드 호출문을 할당\npublic class TPC02 { public static void main(String[] args) { // 프로그래밍 3대 요소 : 변수, 자료형,(DataType), 할당(=) \t// 메모리에 저장되기 위해 =\u0026gt; 크기 + 데이터 유형 =\u0026gt; 자료형 \t// int a; =\u0026gt; 변수선언 / int =\u0026gt; 4byte + 정수 \t// 1+1=2 \tint a, b, c; a=1; b=1; c=a+b; System.out.println(c); float f; // float, double(기본) \tf=34.5f; System.out.println(f); char d; // char =\u0026gt; \u0026#39;\u0026#39; / string =\u0026gt; \u0026#34;\u0026#34; \td=\u0026#39;A\u0026#39;; System.out.println(d); boolean g; g=true; System.out.println(g); // Book bk; \u0026lt;= 설계필요 \t} } 2. 자료형의 종류 \r\n사용자정의자료형은 class를 이용해 제작하며 객체, VO, DTO라 칭한다.\n// Book package kr.bit; // 책(객체) =\u0026gt; 상태정보(제목, 가격, 출판사, 페이지수) + 행위정보(메서드) public class Book { public String title; public int price; public String company; public int page; } // PersonVO package kr.bit; // 회원 =\u0026gt; 이름, 나이, 몸무게, 키 (상태정보 or 속성) public class PersonVO { public String name; public int age; public float weight; public float height; } // 위의 객체는 배열 x \u0026lt;= 배열은 동일한 data / 위의 객체는 class import kr.bit.Book; import kr.bit.PersonVO; public class TPC03 { public static void main(String[] args) { // 관계 PDT VS UDDT \t// 정수 1개를 저장하기 위한 변수를 선언 \tint a; a=10; // 책 1권을 저장하기 위한 객체변수를 선언 \t// 생성자 : 객체를 생성할 때 호출하는 메서드 \t// new : 메모리에 인스턴스 객체 생성 \tBook b; b=new Book(); b.title=\u0026#34;자바\u0026#34;; b.price=15000; b.company=\u0026#34;한빛미디어\u0026#34;; b.page=700; System.out.print(b.title+\u0026#34;\\t\u0026#34;); System.out.print(b.price+\u0026#34;\\t\u0026#34;); System.out.print(b.company+\u0026#34;\\t\u0026#34;); System.out.println(b.page); PersonVO p; p=new PersonVO(); p.name=\u0026#34;차범희\u0026#34;; p.age=26; p.weight=61.5f; p.height=166.7f; System.out.print(p.name+\u0026#34;\\t\u0026#34;); System.out.print(p.age+\u0026#34;\\t\u0026#34;); System.out.print(p.weight+\u0026#34;\\t\u0026#34;); System.out.println(p.height); } } 3. 변수와 배열 \r\n 1차원 배열 :  2차원 배열 :   public class TPC04 { public static void main(String[] args) { // 데이터 이동(변수 vs 배열) \tint a, b, c; a=10; b=20; c=30; // 메서드 호출 \thap(a,b,c); int[] arr=new int[3]; arr[0]=a; arr[1]=b; arr[2]=c; hap1(arr); } public static void hap(int x, int y, int z) { int sum=x+y+z; System.out.println(sum); } public static void hap1(int[] x) { // 반복문 활용가능 \t// int sum=x[0] + x[1] + x[2]; \tint sum=0; for(int i=0;i\u0026lt;x.length;i++) { sum+=x[i]; } System.out.println(sum); } } public class TPC05 { public static void main(String[] args) { int[] a=new int[3]; a[0]=10; a[1]=20; a[2]=30; int sum=0; for(int i=0;i\u0026lt;a.length;i++) { sum+=a[i]; } System.out.println(sum); // 9개의 정수형 변수 생성 =\u0026gt; 2차원 구조 \tint[][] b=new int[3][3]; b[0][0]=1; b[0][1]=2; b[0][2]=3; b[1][0]=1; b[1][1]=2; b[1][2]=3; b[2][0]=1; b[2][1]=2; b[2][2]=3; for(int i=0;i\u0026lt;b.length;i++) { for(int j=0;j\u0026lt;b[i].length;j++) { System.out.print(b[i][j]+\u0026#34;\\t\u0026#34;); } System.out.println(); } // 가변길이 배열 \tint[][] star=new int[5][]; star[0]=new int[1]; star[1]=new int[2]; star[2]=new int[3]; star[3]=new int[4]; star[4]=new int[5]; for(int i=0;i\u0026lt;star.length;i++) { for(int j=0;j\u0026lt;star[i].length;j++) { star[i][j]=\u0026#39;*\u0026#39;; System.out.print((char)star[i][j]); } System.out.println(); } } } ","date":"2021-07-13T00:00:00Z","image":"https://ssabum.github.io/content/java1%EC%9D%BC%EC%B0%A8/java_huf9c84da500ff31d32b76d7b295424dba_281027_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/java1%EC%9D%BC%EC%B0%A8/","title":"[JAVA]1일차"},{"content":"타이타닉 데이터 분석 프로젝트 후기❓ 타이타닉 데이터분석 프로젝트를 진행하면서 느꼈던 궁금증 해결하기!!!\n1. NULL Data 채우는 다양한 방식 데이터 분석 초기 과정에서 가장 중요한 일 중 하나가 바로 결측치/결측값 처리이다.\n여기에 따라 모델 생성과 결과 도출에 이르기까지 큰 영향을 끼치기 때문이다.\n  첫번째 방법, 제거하기\n  목록삭제(Listwise)\n결측치가 존재하는 전체 행을 삭제\n\r\n  단일값 삭제(Pairwise)\n손실된 관측치 자체만 삭제\n\r\n    두번째 방법, 채우기\n  평균화 기법(Popular Averaging)\n가장 널리 사용되는 기술로, 그룹의 평균값을 결측값에 채워준다.\n결측치를 빠르게 채울 수 있는 장점이 있지만, 결측치들이 동일한 값도 가질 수 있기 때문에 데이터셋의 변동을 인위적으로 줄여줘야 한다.\n\r\n  예측 기법(Predictive)\n결측치들의 특성이 무작위로 완전히 관찰되지 않는다고 가정하고 예측모델을 사용하여 결측값을 대치할 예측값을 생성\n회귀 분석 기술을 활용하거나 SVM과 같은 머신러닝 등의 데이터마이닝 방법을 사용\n     2. Feature별 상관관계, Heatmap 해석하기 Heatmap이란? 열을 의미하는 heat와 지도를 뜻하는 map을 합친 단어로 데이터들의 배열을 색상으로 표현\n여러 카테고리 값에 대한 값 변화를 한눈에 알기 쉽다는 장점이 있다.\n\r\n위의 데이터는 월별 비행기 이용 승객수이다. 빨간색이 짙을수록 승객수가 적음을 의미하고 빨간색이 얕아질수록 승객수가 높음을 의미한다.\n데이터 형태가 테이블 형태일때보다 히트맵으로 나타내면 언제 승객이 많은지, 승객수 변화가 어떠한지 쉽게 알 수 있다.\n 3. Label Encoding VS One-Hot Encoding 머신러닝을 위한 대표적인 인코딩 방식으로 Label과 One-Hot이 존재한다.\n  레이블 인코딩은 간단하게 문자열 값을 숫자형 카테고리 값으로 변환한다.\n그러나, 일괄적인 숫자값으로의 변환은 예측능력을 떨어트리는 원인이 될 수 있다.\n숫자에 따라 각 카테고리들의 가중치 차이가 발생할 수 있기 때문으로 선형회귀와 같은 ML알고리즘에서는 맞지 않는다.\n  원-핫 인코딩은 레이블 인코딩의 문제점을 해결하기 위한 인코딩 방식으로\nfeature값의 유형에 따라 새로운 feature를 추가하고 고유 값에 해당하는 칼럼에만 1을 표시하는 방식이다.\n\r\n위의 사진은 가전제품 feature를 원-핫 인코딩을 걸친 것이다.\n주의할 점이있다면 원-핫 인코딩하기 전에 모든 문자열 값이 숫자형 값으로 변환돼야 하며, 입력값으로 2차원 데이터가 필요하다는 것이다.\n  ","date":"2021-07-10T00:00:00Z","image":"https://ssabum.github.io/content/%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A6%AC%EB%B7%B0/end_hu771523524522bf8edc036416ae7f1a7b_21048_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A6%AC%EB%B7%B0/","title":"타이타닉 프로젝트 리뷰"},{"content":"타이타닉 데이터 분석 🚢  본격적으로 데이터분석에 드러가기에 앞서 튜토리얼을 진행해보려한다.\n코딩을 처음 배울때 Hello World를 출력하는 것 처럼 데이터분석의 시작은 타이타닉 데이터이다!!\n Kaggle과 Colab 연동 Google Colab 환경에서 프로젝트를 진행했는데 Kaggle의 data set을 가져오기 위해 하나하나 다운받을 필요없이 API를 이용해 불러올 수 있습니다!\n# kaggle과 colab 연동 !pip install kaggle # kaggle에서 api kaggle.json을 받아서 전송 from google.colab import files files.upload() !mkdir -p ~/.kaggle !cp kaggle.json ~/.kaggle/ !chmod 600 ~/.kaggle/kaggle.json # API로 data set download !kaggle competitions download -c 2019-1st-ml-month-with-kakr # 압축해제 !unzip -q /content/2019-1st-ml-month-with-kakr 왜 하필이면 타이타닉?? 데이터 분석 전체 프로세스를 빠르게 경험할 수 있으며, 접근하기 좋은 Binary Classification 문제이기 때문에\n진행 프로세스  데이터셋 확인   데이터를 수집하고 전처리  탐색적 데이터 분석(EDA)   여러 특성들을 분석하고 상관관계를 확인 시각화를 통해 insight 도출  특성공학(Feature Engineering)   모델의 성능을 높이기 위해 특성을 엔지니어링  모델 개발 및 학습   sklearn, keras 등을 이용해 모델을 제작  모델 예측 및 평가    훈련 데이터를 가지고 모델을 학습시키고, 테스트 데이터를 가지고 예측합니다.\n   1. 데이터셋 확인 # 데이터셋 확인 import os import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import keras import sklearn # seaborn 셋팅 =\u0026gt; matplotlib을 기반으로 다양한 색상 테마와 통계용 기능을 추가한 시각화 패키지 plt.style.use(\u0026#39;seaborn\u0026#39;) sns.set(font_scale=2.5) import missingno as msno import warnings # 경고 메시지 생략 warnings.filterwarnings(\u0026#39;ignore\u0026#39;) %matplotlib inline df_train = pd.read_csv(\u0026#39;train.csv\u0026#39;) df_test = pd.read_csv(\u0026#39;test.csv\u0026#39;) df_submit = pd.read_csv(\u0026#39;sample_submission.csv\u0026#39;) df_train.head() \r\n데이터 Feature 설명  survival - 생존유무 =\u0026gt; target 값 (0=사망, 1=생존) pclass - 티켓클래스 sex - 성별 age - 나이 sibsp - 함께 탑승한 형제자매, 배우자 수 총합 parch - 함꺼 탑승한 부모, 자녀 수 총합 ticket - 티켓 넘버 fare - 탑승 요금 cabin - 객실 넘버 bembarked - 탑승 항구  # 결측치 확인 =\u0026gt; train set과 test set에 비슷하게 age에 20% cabin에 80%의 결측지 발견 df_train.isnull().sum() / df_train.shape[0] \r\nTarget Label 확인 target label이 어떤 distribution을 가지고 있는지 확인 필요 binary classification에서 분포가 어떠냐에 따라 모델의 평가방법이 달라지기 때문에\nf, ax = plt.subplots(1, 2, figsize=(18, 8)) # 파이그래프 df_train[\u0026#39;Survived\u0026#39;].value_counts().plot.pie(explode=[0, 0.1], autopct=\u0026#39;%1.1f%%\u0026#39;, ax=ax[0], shadow=True) ax[0].set_title(\u0026#39;Pie plot - Survived\u0026#39;) ax[0].set_ylabel(\u0026#39;\u0026#39;) # 항목별 개수를 카운트 sns.countplot(\u0026#39;Survived\u0026#39;, data=df_train, ax=ax[1]) ax[1].set_title(\u0026#39;Count plot - Survived\u0026#39;) plt.show() # target label의 분포가 제법 균일하므로 binary classification에 적합 \r\n파이그래프 속성  plt.pie(slice, labels=activities, startangle=90, shadow=True, explode=(0, 0, 0.1, 0), autopct='%1.1f%%')\n   slice: 파이 조각의 데이터\n  labels: 파이 조각의 라벨\n  startangle: 그려지는 파이 조각 시작 위치\n  shadow: 파이 차트의 그림자 효과 유무\n  explode: 파이 조각이 돌출되는 크기\n  autopct: 파이 조각의 전체 대비 백분율\n   2. 탐색적 데이터 분석(Exploratory Data Analysys) Feature별로 데이터 분석 Insight 도출해보자\n1. Pclass  Pclass는 서수형 데이터입니다. Pclass,Survived 를 가져온 후, pclass 로 묶으면 각 pclass 마다 0, 1 이 count가 되는데, 이를 평균내면 각 pclass 별 생존률이 추출  # 생존률 df_train[[\u0026#39;Pclass\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;Pclass\u0026#39;], as_index=True).mean() \r\n# 막대그래프 시각화 df_train[[\u0026#39;Pclass\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;Pclass\u0026#39;], as_index=True).mean().plot.bar() # 생존률에 Pclass가 큰 영향을 미친다고 생각할 수 있다. # 따라서 모델 생성시 해당 feature 사용이 좋을 것이라 판단 \r\n2. Sex f, ax = plt.subplots(1, 2, figsize=(18, 8)) df_train[[\u0026#39;Sex\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;Sex\u0026#39;], as_index=True).mean().plot.bar(ax=ax[0]) ax[0].set_title(\u0026#39;Survived vs Sex\u0026#39;) sns.countplot(\u0026#39;Sex\u0026#39;, hue=\u0026#39;Survived\u0026#39;, data=df_train, ax=ax[1]) ax[1].set_title(\u0026#39;Sex: Survived vs Dead\u0026#39;) plt.show() # 남성보다 여성의 생존확률이 높습니다. # Pclass와 마찬가지로, Sex도 예측 모델에 쓰일 중요 featured임을 알 수 있다. \r\n3. Both Sex and Pclass # factor형의 변수의 시각화를 할 때 유용한 시각화 sns.factorplot(\u0026#39;Pclass\u0026#39;, \u0026#39;Survived\u0026#39;, hue=\u0026#39;Sex\u0026#39;, data=df_train, size=6, aspect=1.5) # 모든 클래스에서 여성의 생존률이 남성보다 높다. \r\n4. Age # 막대그래프는 어떤 분포로 퍼져있는지 확인할 수 없다. 그래서 분포를 확인할 때는 히스토그램을 사용 # but, 히스토그램은 구간을 어떻게 설정하냐에 따라 결과물이 크게 달라진다. # 그 대안으로 분포를 곡선화 시켜주는 커널밀도추정(KDE)을 많이 사용 fig, ax = plt.subplots(1, 1, figsize=(9, 5)) sns.kdeplot(df_train[df_train[\u0026#39;Survived\u0026#39;] == 1][\u0026#39;Age\u0026#39;], ax=ax) sns.kdeplot(df_train[df_train[\u0026#39;Survived\u0026#39;] == 0][\u0026#39;Age\u0026#39;], ax=ax) plt.legend([\u0026#39;Survived == 1\u0026#39;, \u0026#39;Survived == 0\u0026#39;]) plt.show() # 생존 KDE와 사망 KDE를 비교했을때 어린나이 구간에서 생존률이 상대적으로 높음을 알 수 있다. \r\ncummulate_survival_ratio = [] for i in range(1, 80): cummulate_survival_ratio.append(df_train[df_train[\u0026#39;Age\u0026#39;] \u0026lt; i][\u0026#39;Survived\u0026#39;].sum() / len(df_train[df_train[\u0026#39;Age\u0026#39;] \u0026lt; i][\u0026#39;Survived\u0026#39;])) plt.figure(figsize=(7, 7)) plt.plot(cummulate_survival_ratio) plt.title(\u0026#39;Survival rate change depending on range of Age\u0026#39;, y=1.02) plt.ylabel(\u0026#39;Survival rate\u0026#39;) plt.xlabel(\u0026#39;Range of Age(0~x)\u0026#39;) plt.show() # 나이가 어릴수록 생존률이 확실히 증가하는 것을 확인 가능 # Age도 중요 feature임을 확인할 수 있다. \r\n5. Embarked f, ax = plt.subplots(1, 1, figsize=(7, 7)) df_train[[\u0026#39;Embarked\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;Embarked\u0026#39;], as_index=True).mean().sort_values(by=\u0026#39;Survived\u0026#39;, ascending=False).plot.bar(ax=ax) # 탑승항구 별 생존률의 차이가 크진 않다. \r\n# 다른 feature와의 상관관계 f,ax=plt.subplots(2, 2, figsize=(20,15)) sns.countplot(\u0026#39;Embarked\u0026#39;, data=df_train, ax=ax[0,0]) ax[0,0].set_title(\u0026#39;(1) No. Of Passengers Boarded\u0026#39;) sns.countplot(\u0026#39;Embarked\u0026#39;, hue=\u0026#39;Sex\u0026#39;, data=df_train, ax=ax[0,1]) ax[0,1].set_title(\u0026#39;(2) Male-Female Split for Embarked\u0026#39;) sns.countplot(\u0026#39;Embarked\u0026#39;, hue=\u0026#39;Survived\u0026#39;, data=df_train, ax=ax[1,0]) ax[1,0].set_title(\u0026#39;(3) Embarked vs Survived\u0026#39;) sns.countplot(\u0026#39;Embarked\u0026#39;, hue=\u0026#39;Pclass\u0026#39;, data=df_train, ax=ax[1,1]) ax[1,1].set_title(\u0026#39;(4) Embarked vs Pclass\u0026#39;) plt.subplots_adjust(wspace=0.2, hspace=0.5) plt.show() \r\n Figure(1) - 전체적으로 봤을 때, S 에서 가장 많은 사람이 탑승했습니다. Figure(2) - C와 Q 는 남녀의 비율이 비슷하고, S는 남자가 더 많습니다. Figure(3) - 생존확률이 S 경우 많이 낮은 걸 볼 수 있습니다. (이전 그래프에서 봤었습니다) Figure(4) - Class 로 split 해서 보니, C가 생존확률이 높은건 클래스가 높은 사람이 많이 타서 그렇습니다. S는 3rd class 가 많아서 생존확률이 낮게 나옵니다.  6. Family(Sibsp + Parch) # Sibsp와 Parch를 합치면 함께 탑승한 가족의 수가 되므로 새로운 Feature 생성 df_train[\u0026#39;FamilySize\u0026#39;] = df_train[\u0026#39;SibSp\u0026#39;] + df_train[\u0026#39;Parch\u0026#39;] + 1 # 자신을 포함해야하니 1을 더합니다 df_test[\u0026#39;FamilySize\u0026#39;] = df_test[\u0026#39;SibSp\u0026#39;] + df_test[\u0026#39;Parch\u0026#39;] + 1 # 자신을 포함해야하니 1을 더합니다 f,ax=plt.subplots(1, 3, figsize=(40,10)) sns.countplot(\u0026#39;FamilySize\u0026#39;, data=df_train, ax=ax[0]) ax[0].set_title(\u0026#39;(1) No. Of Passengers Boarded\u0026#39;, y=1.02) sns.countplot(\u0026#39;FamilySize\u0026#39;, hue=\u0026#39;Survived\u0026#39;, data=df_train, ax=ax[1]) ax[1].set_title(\u0026#39;(2) Survived countplot depending on FamilySize\u0026#39;, y=1.02) df_train[[\u0026#39;FamilySize\u0026#39;, \u0026#39;Survived\u0026#39;]].groupby([\u0026#39;FamilySize\u0026#39;], as_index=True).mean().sort_values(by=\u0026#39;Survived\u0026#39;, ascending=False).plot.bar(ax=ax[2]) ax[2].set_title(\u0026#39;(3) Survived rate depending on FamilySize\u0026#39;, y=1.02) plt.subplots_adjust(wspace=0.2, hspace=0.5) plt.show() \r\n Figure (1) - 가족크기가 1~11까지 있음을 볼 수 있습니다. 대부분 1명이고 그 다음으로 2, 3, 4명입니다. Figure (2), (3) - 가족 크기에 따른 생존비교입니다. 가족이 4명인 경우가 가장 생존확률이 높습니다, 가족수가 많아질수록, (5, 6, 7, 8, 11) 생존확률이 낮아지네요. 가족수가 너무 작아도(1), 너무 커도(5, 6, 8, 11) 생존 확률이 작네요. 3~4명 선에서 생존확률이 높은 걸 확인할 수 있습니다.  7. Fare # 탑승요금은 연속적인 데이터이므로 히스토그램 시각화 fig, ax = plt.subplots(1, 1, figsize=(8, 8)) g = sns.distplot(df_train[\u0026#39;Fare\u0026#39;], color=\u0026#39;b\u0026#39;, label=\u0026#39;Skewness : {:.2f}\u0026#39;.format(df_train[\u0026#39;Fare\u0026#39;].skew()), ax=ax) g = g.legend(loc=\u0026#39;best\u0026#39;) # 특이하기도 train set 말고 test set에 Fare 피쳐에 널 값이 하나 존재하는 것을 확인할 수 있었습니다. # 그래서 평균 값으로 해당 널값을 넣어줍니다. df_test.loc[df_test.Fare.isnull(), \u0026#39;Fare\u0026#39;] = df_test[\u0026#39;Fare\u0026#39;].mean() # testset 에 있는 nan value 를 평균값으로 치환합니다. # log를 취해 보기 편하게 변환 df_train[\u0026#39;Fare\u0026#39;] = df_train[\u0026#39;Fare\u0026#39;].map(lambda i: np.log(i) if i \u0026gt; 0 else 0) df_test[\u0026#39;Fare\u0026#39;] = df_test[\u0026#39;Fare\u0026#39;].map(lambda i: np.log(i) if i \u0026gt; 0 else 0) fig, ax = plt.subplots(1, 1, figsize=(8, 8)) g = sns.distplot(df_train[\u0026#39;Fare\u0026#39;], color=\u0026#39;b\u0026#39;, label=\u0026#39;Skewness : {:.2f}\u0026#39;.format(df_train[\u0026#39;Fare\u0026#39;].skew()), ax=ax) g = g.legend(loc=\u0026#39;best\u0026#39;) \r\n8. Cabin NaN이 대략 80% 이므로, 생존에 영향을 미칠 중요한 정보를 얻어내기가 쉽지는 않습니다.\n9. Ticket NaN은 없지만 이 데이터로 유효한 결과를 뽑아내기위해선 아이디어가 필요\n 3. 특성공학(Feature Engineering) Fill Null null data를 어떻게 채우느냐에 따라 모델의 성능이 좌지우지되므로 중요, train 뿐만 아니라 test도 똑같이 적용\n1. Age df_train[\u0026#39;Initial\u0026#39;]= df_train.Name.str.extract(\u0026#39;([A-Za-z]+)\\.\u0026#39;) #lets extract the Salutations df_test[\u0026#39;Initial\u0026#39;]= df_test.Name.str.extract(\u0026#39;([A-Za-z]+)\\.\u0026#39;) #lets extract the Salutations # Initial과 Sex간의 count pd.crosstab(df_train[\u0026#39;Initial\u0026#39;], df_train[\u0026#39;Sex\u0026#39;]).T.style.background_gradient(cmap=\u0026#39;summer_r\u0026#39;) #Checking the Initials with the Sex df_train[\u0026#39;Initial\u0026#39;].replace([\u0026#39;Mlle\u0026#39;,\u0026#39;Mme\u0026#39;,\u0026#39;Ms\u0026#39;,\u0026#39;Dr\u0026#39;,\u0026#39;Major\u0026#39;,\u0026#39;Lady\u0026#39;,\u0026#39;Countess\u0026#39;,\u0026#39;Jonkheer\u0026#39;,\u0026#39;Col\u0026#39;,\u0026#39;Rev\u0026#39;,\u0026#39;Capt\u0026#39;,\u0026#39;Sir\u0026#39;,\u0026#39;Don\u0026#39;, \u0026#39;Dona\u0026#39;], [\u0026#39;Miss\u0026#39;,\u0026#39;Miss\u0026#39;,\u0026#39;Miss\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mrs\u0026#39;,\u0026#39;Mrs\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;, \u0026#39;Mr\u0026#39;],inplace=True) df_test[\u0026#39;Initial\u0026#39;].replace([\u0026#39;Mlle\u0026#39;,\u0026#39;Mme\u0026#39;,\u0026#39;Ms\u0026#39;,\u0026#39;Dr\u0026#39;,\u0026#39;Major\u0026#39;,\u0026#39;Lady\u0026#39;,\u0026#39;Countess\u0026#39;,\u0026#39;Jonkheer\u0026#39;,\u0026#39;Col\u0026#39;,\u0026#39;Rev\u0026#39;,\u0026#39;Capt\u0026#39;,\u0026#39;Sir\u0026#39;,\u0026#39;Don\u0026#39;, \u0026#39;Dona\u0026#39;], [\u0026#39;Miss\u0026#39;,\u0026#39;Miss\u0026#39;,\u0026#39;Miss\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mrs\u0026#39;,\u0026#39;Mrs\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Other\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;,\u0026#39;Mr\u0026#39;, \u0026#39;Mr\u0026#39;],inplace=True) # train 에서 얻은 statistics 를 기반으로 null data 채우기 df_train.groupby(\u0026#39;Initial\u0026#39;).mean() # 각 initial 그룹별 Age 평균 값을 사용해서 채우기 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Mr\u0026#39;),\u0026#39;Age\u0026#39;] = 33 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Mrs\u0026#39;),\u0026#39;Age\u0026#39;] = 36 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Master\u0026#39;),\u0026#39;Age\u0026#39;] = 5 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Miss\u0026#39;),\u0026#39;Age\u0026#39;] = 22 df_train.loc[(df_train.Age.isnull())\u0026amp;(df_train.Initial==\u0026#39;Other\u0026#39;),\u0026#39;Age\u0026#39;] = 46 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Mr\u0026#39;),\u0026#39;Age\u0026#39;] = 33 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Mrs\u0026#39;),\u0026#39;Age\u0026#39;] = 36 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Master\u0026#39;),\u0026#39;Age\u0026#39;] = 5 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Miss\u0026#39;),\u0026#39;Age\u0026#39;] = 22 df_test.loc[(df_test.Age.isnull())\u0026amp;(df_test.Initial==\u0026#39;Other\u0026#39;),\u0026#39;Age\u0026#39;] = 46 2. Embarked # S에서 가장 많이 탔으므로 S로 채우기 df_train[\u0026#39;Embarked\u0026#39;].fillna(\u0026#39;S\u0026#39;, inplace=True) df_train.isnull().sum()[df_train.isnull().sum() \u0026gt; 0] Change Age Age는 continuous feature이지만 그룹화하여 카테코리화 시켜줄 수 있다. continous를 categorical로 바꾸면 impormation loss가 생길 수 있으므로 주의\ndef category_age(x): if x \u0026lt; 10: return 0 elif x \u0026lt; 20: return 1 elif x \u0026lt; 30: return 2 elif x \u0026lt; 40: return 3 elif x \u0026lt; 50: return 4 elif x \u0026lt; 60: return 5 elif x \u0026lt; 70: return 6 else: return 7 df_train[\u0026#39;Age_cat\u0026#39;] = df_train[\u0026#39;Age\u0026#39;].apply(category_age) df_test[\u0026#39;Age_cat\u0026#39;] = df_test[\u0026#39;Age\u0026#39;].apply(category_age) \r\nChange Initial, Embarked and Sex 컴퓨터가 인식할 수 있도록 수치화\ndf_train[\u0026#39;Initial\u0026#39;] = df_train[\u0026#39;Initial\u0026#39;].map({\u0026#39;Master\u0026#39;: 0, \u0026#39;Miss\u0026#39;: 1, \u0026#39;Mr\u0026#39;: 2, \u0026#39;Mrs\u0026#39;: 3, \u0026#39;Other\u0026#39;: 4}) df_test[\u0026#39;Initial\u0026#39;] = df_test[\u0026#39;Initial\u0026#39;].map({\u0026#39;Master\u0026#39;: 0, \u0026#39;Miss\u0026#39;: 1, \u0026#39;Mr\u0026#39;: 2, \u0026#39;Mrs\u0026#39;: 3, \u0026#39;Other\u0026#39;: 4}) df_train[\u0026#39;Embarked\u0026#39;] = df_train[\u0026#39;Embarked\u0026#39;].map({\u0026#39;C\u0026#39;: 0, \u0026#39;Q\u0026#39;: 1, \u0026#39;S\u0026#39;: 2}) df_test[\u0026#39;Embarked\u0026#39;] = df_test[\u0026#39;Embarked\u0026#39;].map({\u0026#39;C\u0026#39;: 0, \u0026#39;Q\u0026#39;: 1, \u0026#39;S\u0026#39;: 2}) df_train[\u0026#39;Sex\u0026#39;] = df_train[\u0026#39;Sex\u0026#39;].map({\u0026#39;female\u0026#39;: 0, \u0026#39;male\u0026#39;: 1}) df_test[\u0026#39;Sex\u0026#39;] = df_test[\u0026#39;Sex\u0026#39;].map({\u0026#39;female\u0026#39;: 0, \u0026#39;male\u0026#39;: 1}) # 각 feature별 상관관계 시각화 heatmap_data = df_train[[\u0026#39;Survived\u0026#39;, \u0026#39;Pclass\u0026#39;, \u0026#39;Sex\u0026#39;, \u0026#39;Fare\u0026#39;, \u0026#39;Embarked\u0026#39;, \u0026#39;FamilySize\u0026#39;, \u0026#39;Initial\u0026#39;, \u0026#39;Age_cat\u0026#39;, \u0026#39;Age\u0026#39;]] colormap = plt.cm.RdBu plt.figure(figsize=(14, 12)) plt.title(\u0026#39;Pearson Correlation of Features\u0026#39;, y=1.05, size=15) sns.heatmap(heatmap_data.astype(float).corr(), linewidths=0.1, vmax=1.0, square=True, cmap=colormap, linecolor=\u0026#39;white\u0026#39;, annot=True, annot_kws={\u0026#34;size\u0026#34;: 16}) del heatmap_data \r\n Sex 와 Pclass 가 Survived 에 상관관계가 어느 정도 있음을 볼 수 있습니다. 생각보다 fare 와 Embarked 도 상관관계가 있음을 볼 수 있습니다. 강한 상관관계를 가지는 feature들이 없다. 따라서 모델을 학습시킬 때, 불필요한 feature 가 없다.  데이터전처리(Data Preprocessing) 모델의 성능을 높이기 위해 데이터 전처리 과정\nOne-hot encoding on Initiall and Embarked One-hot encoding을 통해 각 클래스간 연관성을 동이하게 생성category가 많을 경우 column이 너무 많이 생성되어 차원의 저주 발생 주의\ndf_train = pd.get_dummies(df_train, columns=[\u0026#39;Initial\u0026#39;], prefix=\u0026#39;Initial\u0026#39;) df_test = pd.get_dummies(df_test, columns=[\u0026#39;Initial\u0026#39;], prefix=\u0026#39;Initial\u0026#39;) \r\ndf_train = pd.get_dummies(df_train, columns=[\u0026#39;Embarked\u0026#39;], prefix=\u0026#39;Embarked\u0026#39;) df_test = pd.get_dummies(df_test, columns=[\u0026#39;Embarked\u0026#39;], prefix=\u0026#39;Embarked\u0026#39;) Drop Columns 필요없는 피쳐 제거\ndf_train.drop([\u0026#39;PassengerId\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;SibSp\u0026#39;, \u0026#39;Parch\u0026#39;, \u0026#39;Ticket\u0026#39;, \u0026#39;Cabin\u0026#39;], axis=1, inplace=True) df_test.drop([\u0026#39;PassengerId\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;SibSp\u0026#39;, \u0026#39;Parch\u0026#39;, \u0026#39;Ticket\u0026#39;, \u0026#39;Cabin\u0026#39;], axis=1, inplace=True) 4. 모델 개발 및 학습 Sklearn은 머신러닝에 관련된 모든 작업들이 손쉬운 인터페이스로 구현되어 있다. 현재 우리는 train set의 survived를 제외한 input을 가지고 모델을 최적화 시켜 탑승객의 생존유무를 판단하는 모델을 생성 그 후 test set을 input으로 주어서 탑승객의 생존유무를 예측\n#importing all the required ML packages from sklearn.ensemble import RandomForestClassifier # 유명한 randomforestclassfier 입니다.  from sklearn import metrics # 모델의 평가를 위해서 씁니다 from sklearn.model_selection import train_test_split # traning set을 쉽게 나눠주는 함수입니다. ### Preparation - Split dataset into train, valid, test set ​```python X_train = df_train.drop(\u0026#39;Survived\u0026#39;, axis=1).values target_label = df_train[\u0026#39;Survived\u0026#39;].values X_test = df_test.values X_tr, X_vld, y_tr, y_vld = train_test_split(X_train, target_label, test_size=0.2, random_state=2018) Model generation and prediction Random Forest 여러 알고리즘 중 랜덤포레스트를 사용 랜덤포레스트는 결정트리기반 모델로 여러 결정 트리들을 앙상블한 모델\nmodel = RandomForestClassifier() # 생성 model.fit(X_tr, y_tr) # 학습 prediction = model.predict(X_vld) # 예측 print(\u0026#39;총 {}명 중 {:.2f}% 정확도로 생존을 맞춤\u0026#39;.format(y_vld.shape[0], 100 * metrics.accuracy_score(prediction, y_vld))) # 총 179명 중 81.56% 정확도로 생존을 맞춤 # 학습된 모델은 feature importance를 가지게 되는데, # 이는 어떤 feature가 결과에 영향을 많이 미쳤는지 확인할 수 있다. from pandas import Series feature_importance = model.feature_importances_ Series_feat_imp = Series(feature_importance, index=df_test.columns) plt.figure(figsize=(8, 8)) Series_feat_imp.sort_values(ascending=True).plot.barh() plt.xlabel(\u0026#39;Feature importance\u0026#39;) plt.ylabel(\u0026#39;Feature\u0026#39;) plt.show() \r\nNN모델(Neural Network model) - 딥러닝 모델 from keras.models import Sequential from keras.layers.core import Dense, Dropout from keras.optimizers import Adam, SGD nn_model = Sequential() nn_model.add(Dense(32,activation=\u0026#39;relu\u0026#39;,input_shape=(14,))) nn_model.add(Dropout(0.2)) nn_model.add(Dense(64,activation=\u0026#39;relu\u0026#39;)) nn_model.add(Dropout(0.2)) nn_model.add(Dense(32,activation=\u0026#39;relu\u0026#39;)) nn_model.add(Dropout(0.2)) nn_model.add(Dense(1,activation=\u0026#39;sigmoid\u0026#39;)) Loss = \u0026#39;binary_crossentropy\u0026#39; nn_model.compile(loss=Loss,optimizer=Adam(),metrics=[\u0026#39;accuracy\u0026#39;]) history = nn_model.fit(X_tr,y_tr, batch_size=64, epochs=500, validation_data=(X_vld, y_vld), verbose=1) hists = [history] hist_df = pd.concat([pd.DataFrame(hist.history) for hist in hists], sort=True) hist_df.index = np.arange(1, len(hist_df)+1) fig, axs = plt.subplots(nrows=2, sharex=True, figsize=(16, 10)) axs[0].plot(hist_df.val_accuracy, lw=5, label=\u0026#39;Validation Accuracy\u0026#39;) axs[0].plot(hist_df.accuracy, lw=5, label=\u0026#39;Training Accuracy\u0026#39;) axs[0].set_ylabel(\u0026#39;Accuracy\u0026#39;) axs[0].set_xlabel(\u0026#39;Epoch\u0026#39;) axs[0].grid() axs[0].legend(loc=0) axs[1].plot(hist_df.val_loss, lw=5, label=\u0026#39;Validation MLogLoss\u0026#39;) axs[1].plot(hist_df.loss, lw=5, label=\u0026#39;Training MLogLoss\u0026#39;) axs[1].set_ylabel(\u0026#39;MLogLoss\u0026#39;) axs[1].set_xlabel(\u0026#39;Epoch\u0026#39;) axs[1].grid() axs[1].legend(loc=0) fig.savefig(\u0026#39;hist.png\u0026#39;, dpi=300) plt.show(); \r\n5. 모델 예측 및 평가 랜덤포레스트 submission = pd.read_csv(\u0026#39;sample_submission.csv\u0026#39;) prediction = model.predict(X_test) submission[\u0026#39;Survived\u0026#39;] = prediction submission.to_csv(\u0026#39;my_first_submission.csv\u0026#39;, index=False) # 정확도 스코어: 0.75598 NN모델 submission = pd.read_csv(\u0026#39;sample_submission.csv\u0026#39;) prediction = nn_model.predict(X_test) prediction = prediction \u0026gt; 0.5 prediction = prediction.astype(np.int) prediction = prediction.T[0] submission[\u0026#39;Survived\u0026#39;] = prediction submission.to_csv(\u0026#39;my_nn_submission.csv\u0026#39;, index=False) # 정확도 사코어: 0.77990  Google Colab환경에서 진행하고 markdown으로 포스팅하는 거라 설명이 부족한 점은 양해바랍니다;;💦💦\n예전에 잠깐 해보았던 데이터분석이지만 오랜만에 다시한번 해보니 감회가 새로웠고 진행하는 과정에서 느낀 궁금점들은 따로 정리하여 포스팅하도록 하겠습니당!!!\n원본소스코드.ipynb 👉 https://github.com/ssabum/note/blob/master/data_analysis/titanic.ipynb\n","date":"2021-07-09T00:00:00Z","image":"https://ssabum.github.io/content/data-analysis-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89/titanic_hu283fdd82a3189859b359fc7b8f11d672_184666_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/data-analysis-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89/","title":"Data analysis 타이타닉"},{"content":"내 근황\u0026hellip; 그동안 블로그 활동을 하지 못했는데\u0026hellip;마음이 뜬 것도 있고, ssafy 1학기 프로젝트에 정신 팔린 것도 있고\u0026hellip;\n이제 다시 맘먹고 열심히 할 생각이다!!\n생각보다 난 한게 아무것도 없었고 앞으로 할 수 있는게 많다는 뜻이니!!\n그래도 그동안 ssafy 1학기를 잘 마무리하고, 정보처리기사와 sqld 자격정을 취득했다.\n이제는 ssafy 2학기 프로젝트를 진행하면서 본격적으로 내 실력을 키우기 위한 공부를 시작해야겠지!\n","date":"2021-07-09T00:00:00Z","image":"https://ssabum.github.io/content/%EA%B7%BC%ED%99%A9%EC%9D%B4%EC%9A%94/todo_hub8956bba192ccf8149451449a4cced01_62392_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/%EA%B7%BC%ED%99%A9%EC%9D%B4%EC%9A%94/","title":"근황이요"},{"content":"1780번 종이의 개수 문제 보러가기\n🅰 코드 import sys N = int(sys.stdin.readline()) data = [] for _ in range(N): data.append(list(map(int, sys.stdin.readline().split()))) result = {\u0026#34;-1\u0026#34;: 0, \u0026#34;0\u0026#34;: 0, \u0026#34;1\u0026#34;: 0} # 체크 함수 def check(row, col, N): value = data[row][col] for i in range(N): for j in range(N): if value != data[row + i][col + j]: # 9분할 check(row, col, N // 3) check(row, col + N // 3, N // 3) check(row, col + N * 2 // 3, N // 3) check(row + N // 3, col, N // 3) check(row + N // 3, col + N // 3, N // 3) check(row + N // 3, col + N * 2 // 3, N // 3) check(row + N * 2 // 3, col, N // 3) check(row + N * 2 // 3, col + N // 3, N // 3) check(row + N * 2 // 3, col + N * 2 // 3, N // 3) return result[str(value)] += 1 check(0, 0, N) # 결과 출력 print(result[\u0026#34;-1\u0026#34;]) print(result[\u0026#34;0\u0026#34;]) print(result[\u0026#34;1\u0026#34;]) ✅ 후기  전에 풀어보았던 색종이 문제와 유사했다. 그때는 4분할 이었지만 지금은 9분할이라는 차이가 있을뿐?.. 그림으로 좌표를 찍어내면 다음과 같다.  \r\n 단지 좀 귀찮았던 것은 분할하는 과정을 계속 반복해줬는데 이걸 한번에 처리할 방법이 없는지 고민이 되었다\u0026hellip;💦  ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1780%EB%B2%88-%EC%A2%85%EC%9D%B4%EC%9D%98-%EA%B0%9C%EC%88%98/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1780%EB%B2%88-%EC%A2%85%EC%9D%B4%EC%9D%98-%EA%B0%9C%EC%88%98/","title":"백준 1780번 종이의 개수"},{"content":"1927번 최소 힙 문제 보러가기\n🅰 코드 import heapq import sys N = int(input()) heap = [] for _ in range(N): num = int(sys.stdin.readline()) if num == 0: if heap: print(heapq.heappop(heap)) else: print(0) else: heapq.heappush(heap, num) ✅ 후기   heap을 다루는 문제로 숫자가 들어왔을 때는 heappush로 출력하고 0이 들어오면 heappop을 한 뒤 print를 하도록 구상하였다.\n  이 문제의 중점은 시간단축을 위해 sys.stdin.readline()과 heapq을 사용하는 것이다. 전에도 종종 언급했었지만 다시한번 정리하자면 인풋받는 메소드의 속도차이는 다음과 같다.\nsys.stdin.readline \u0026lt; raw_input() \u0026lt; input() # sys.sydin.readline: 한줄의 문자열을 통째로 반환 / sys.stdin: 여러줄 입력받을 때 # raw_line: 문자열을 반환 # input: raw_input을 evaluate한 결과를 반환   ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1927%EB%B2%88-%EC%B5%9C%EC%86%8C-%ED%9E%99/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1927%EB%B2%88-%EC%B5%9C%EC%86%8C-%ED%9E%99/","title":"백준 1927번 최소 힙"},{"content":"1931번 회의실 배정 문제 보러가기\n🅰 코드 n = int(input()) arr = [] for i in range(n): tmp = list(map(int, input().split())) arr.append(tmp) # 람다함수 쓰는것 익숙해지기!!! arr.sort(key=lambda x: (x[1], x[0])) count = 0 end = 0 for i in range(n): if end \u0026lt;= arr[i][0]: count += 1 end = arr[i][1] print(count) ✅ 후기  문제에서 주어지는 입력값을 받은 다음 lambda함수를 사용해 끝나는 시간과 시작하는 시간순으로 두번 정렬해주면 금방 해결할 수 있는 문제이다. 새삼 느끼지만 lambda함수는 정말 간단하고 편리한 것 같다. 자주 사용하는 버릇을 들여야 겠다;;😮  ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1931%EB%B2%88-%ED%9A%8C%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1931%EB%B2%88-%ED%9A%8C%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/","title":"백준 1931번 회의실 배정"},{"content":"1992번 쿼드트리 문제 보러가기\n🅰 코드 # 정답을 담을 변수 result = [] def Test(a): # 모두 0이거나 모두 1이면 끝 if sum( sum(a,[]) ) == 0 or len( sum(a,[]) ) == sum(a,[]).count(1): if sum( sum(a,[])) == 0: result.append(\u0026#39;0\u0026#39;) else: result.append(\u0026#39;1\u0026#39;) return else: result.append(\u0026#39;(\u0026#39;) div = int(len(a)/2) # a/2 x a/2 크기의 행렬을 만들기위해. tmp_l =[] # 좌측 tmp_r =[] # 우측 # 한행씩 불러온다. for sub in a: # 1/2 앞쪽 열 tmp_l.append(sub[0:div]) # 1/2 뒷쪽 열 tmp_r.append(sub[div:]) # tmp_l,tmp_r이 div x div 크기라면 if len(tmp_l) == div: Test(tmp_l) # 좌측값 Test(tmp_r) # 우측값 tmp_r = [] tmp_l = [] result.append(\u0026#39;)\u0026#39;) n = input() a = [] for i in range(int(n)): row = input() tmp = [] for v in row: tmp.append(int(v)) a.append(tmp) Test(a) print( \u0026#39;\u0026#39;.join(result) ) ✅ 후기   분할정복, 재귀를 이용한 문제로 큰 가닥을 잡지 못해서 굉장히 헤맸다. 그래서 인터넷의 도움을 사알짝 받긴 했지만\u0026hellip; 알고리즘은 다음과 같은 순서로 진행된다.\n1) 십자가로 쪼갠다.(분할) 2) 각각의 섹션을 확인한다. 3) 모두 0이거나 1이라면 출력한다. 아니면 반복한다. \r\n  ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1992%EB%B2%88-%EC%BF%BC%EB%93%9C%ED%8A%B8%EB%A6%AC/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1992%EB%B2%88-%EC%BF%BC%EB%93%9C%ED%8A%B8%EB%A6%AC/","title":"백준 1992번 쿼드트리"},{"content":"2579번 계단 오르기 문제 보러가기\n🅰 코드 import sys input = sys.stdin.readline n = int(input()) stairs = [] res = [] for i in range(n): stairs.append(int(input())) if n==1: print(stairs[0]) exit() elif n == 2: print(max(stairs[0]+stairs[1], stairs[1])) exit() res.append(stairs[0]) res.append(max(res[0]+stairs[1], stairs[1])) res.append(max(res[0]+stairs[2], stairs[1]+stairs[2])) for i in range(3, n): res.append(max(res[i-2]+stairs[i], res[i-3]+stairs[i-1]+stairs[i])) print(res[-1]) ✅ 후기   DP문제로 각 계단의 경우의 수마다 2가지의 경우를 고려하면서 진행해 나간다.\n첫번째 경우) 2계단 전에서 한번에 올라오는 경우 두번째 경우) 3계단 전에서 2계단 한번에 올라온 후 1계단 올라온 경우   ","date":"2021-05-03T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-2579%EB%B2%88-%ED%9A%8C%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-2579%EB%B2%88-%ED%9A%8C%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/","title":"백준 2579번 회의실 배정"},{"content":"1676번 팩토리얼 0의 개수 문제 보러가기\n🅰 코드 # n 입력 (0 ~ 500) N = int(input()) # 팩토리얼 계산 # 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수 → 5의 개수 print(N//5 + N//25 + N//125) ✅ 후기  알고리즘 코딩 문제라기 보다는 그냥 창의력 문제인 느낌이 물씬 풍겼다. 규칙을 찾기 위해 30!까지 숫자를 나열해 보면서 코드에서도 나와 있듯이 5의 개수로 0의 개수가 정해지는 규칙이 있다. 여기서 주의 할 점이 5, 25, 125를 따로 생각해준 것처럼 5의 제곱 형태일 때는 여러개가 있기 때문에 이점을 고려해야 한다는 것이다. 💯  ","date":"2021-04-22T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1676%EB%B2%88-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC-0%EC%9D%98-%EA%B0%9C%EC%88%98/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1676%EB%B2%88-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC-0%EC%9D%98-%EA%B0%9C%EC%88%98/","title":"백준 1676번 팩토리얼 0의 개수"},{"content":"1697번 숨바꼭질 문제 보러가기\n🅰 설계   수빈이와 동생의 위치가 주어졌을때 수빈이가 동생의 위치로 이동할 수 있는 최소 거리를 찾는 것이 문제의 목표이다.\n  현재의 위치에서 이동할 수 있는 수단이 3가지이기 때문에 BFS로 접근하면 되겠다 생각하고 풀이해 나갔지만 문제에서 요구하는 정확한 알고리즘 구조를 짜기가 어려웠다\u0026hellip;💦\n  또한 처음에 또 실수한 부분이 아무생각 없이 list를 이용해 queue를 구현하려 했다는 것이다.\npython에서 list로 queue를 구현하면 시간복잡도가 O(n)으로 매우 느리다. 따라서 collections의 deque를 이용해야 하며, 이때 시간복잡도는 O(1)로 빠르다.\n  ✔ 정답 코드 구글링 from collections import deque def bfs(): q = deque() q.append(N) while q: v = q.popleft() if v == K: print(time[v]) return for next_step in (v-1, v+1, v*2): if 0 \u0026lt;= next_step \u0026lt; MAX and not time[next_step]: time[next_step] = time[v] + 1 q.append(next_step) MAX = 100001 N, K = map(int, input().split()) time = [0]*MAX bfs() ✅ 후기   아직까지도 BFS, DFS 를 내 입맛대로 자유롭게 구현하는 것이 어려웠고..\nD1이라는 난이도에 쫄았던 것 같다;; 많은 배움이 필요하다\u0026hellip;\n  ","date":"2021-04-22T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1697%EB%B2%88-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1697%EB%B2%88-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/","title":"백준 1697번 숨바꼭질"},{"content":"1764번 듣보잡 문제 보러가기\n🅰 코드 # N: 듣도 못한 사람 (~ 500000) # M: 보도 못한 사람 (~ 500000) N , M = map(int,input().split()) # 중복되는 이름을 없애기 위해 arr_N = set() arr_M = set() for _ in range(N): arr_N.add(input()) for _ in range(M): arr_M.add(input()) # 교집합 개수 출력 arr = sorted(list(arr_N \u0026amp; arr_M)) print(len(arr)) # 교집합 이름 출력 for i in arr: print(i) ✅ 후기   문제에서 주어진 대로 중복을 허용하지 않는 두개의 그룹SET으로 나누어 차례로 추가해주고 출력해주는 문제였다.\n  문제 진행에 있어 교집합을 구하는 부분이 등장하는데 이때 교집합 뿐만 아니라 합집합, 차집합 등 다양한 집합을 python으로 다루는 내용을 정리한 페이지를 참조했다.\n 참고로 대칭차집합은 합집합에서 교집합을 뺀 집합을 지칭한다.\n   ","date":"2021-04-22T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1764%EB%B2%88-%EB%93%A3%EB%B3%B4%EC%9E%A1/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1764%EB%B2%88-%EB%93%A3%EB%B3%B4%EC%9E%A1/","title":"백준 1764번 듣보잡"},{"content":"SSAFY(삼성 청년 SW 아카데미)👨‍🏫 \r\n삼성 청년 SW 아카데미(SSAFY)는 삼성의 SW 교육 경험과 고용노동부의 취업지원 노하우를 바탕으로 취업 준비생에게 SW 역량 향상 교육 및 다양한 취업지원 서비스를 제공하여 취업에 성공하도록 돕는 프로그램입니다.\n현재 저는 ssafy 5기를 진행중에 있고 이제 6기를 모집한다는 소식을 접하게 되어 보다 많은 사람들이 이 기회를 잡았으면 좋겠어서 글을 남기게 되었습니다!!!😎\n지원안내   지원자격\n연령 : 만 29세 이하\n학력 : 국내외 4년제 대학 졸업자 및 21.8월 졸업 예정자(전공무관)\n  재직여부 및 기타사항\n현재 미취업자 대상으로 교육시작일 교육 입과 가능한 자\n교육기간 중 통학 가능한 자\n병역필 또는 면제자로 해외여행에 결격 사유가 없는 자\n  교육생 지원내용\nSW교육 무료 제공 및 교육지원비 지급\n성정우수자 삼성전자 해외연구소 실습기회 부여\n교육 중 삼성 SW역량 테스트 응시기회 제공\n개인별 진로 컨설팅 등 다양한 취업지원 서비스 제공\n  보다 자세한 사항은 ssafy 홈페이지에 들어가면 확인하실 수 있습니다.\n또한 개인적으로 궁금한 사항은 qqq960909@likelion.org로 문의 주시면 알려줄 수 있는 범위 내에서 알려드리도록 하겠습니다!!\n","date":"2021-04-14T00:00:00Z","image":"https://ssabum.github.io/content/samsung-sw-academy-for-youth/ssafy_hue71d9469f60f090ffbbc678fbd9daff1_167607_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/samsung-sw-academy-for-youth/","title":"SAMSUNG SW ACADEMY FOR YOUTH"},{"content":"광주인공지능사관학교👩‍🏫 광주 인공지능사관학교는 멋쟁이사자처럼의 IT교육 노하우와 광주광역시 \u0026amp; 광주정보문화산업진흥원의 인공지능 클러스터 사업을 바탕으로 인공지능 특화 교육을 제공하여 AI 전문인재로 성장할 수 있도록 돕는 교육 프로그램입니다.\n\r\n작년에 개관하여 저는 광인사 1기를 수료하였고 현재 2기 모집을 마감한걸로 알고 있습니다. 2기 지원자들이나 광인사에 관심이 있으신 분들에게 도움을 드리기 위해 글을 남기게 되었습니다!!!😎\n지원안내   지원자격\n연령 : 만 39세 이하\n지역 : 전국 지원 가능 (광주 권역 50% 이상 선발 예정)\n  교육일정\n온라인 Pre → 중고급 과정 → 해커톤 → 프로젝트 → 취업지원 및 멘토링 특강\n  보다 자세한 사항은 광인사 안내 홈페이지에 들어가면 확인하실 수 있습니다.\n또한 개인적으로 궁금한 사항은 qqq960909@likelion.org로 문의 주시면 알려줄 수 있는 범위 내에서 알려드리도록 하겠습니다!!\n","date":"2021-04-14T00:00:00Z","image":"https://ssabum.github.io/content/%EA%B4%91%EC%A3%BC%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5%EC%82%AC%EA%B4%80%ED%95%99%EA%B5%90/%EA%B4%91%EC%9D%B8%EC%82%AC_hu719e3fdc9e4ff866a1cd41d00cfaa62f_468099_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EA%B4%91%EC%A3%BC%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5%EC%82%AC%EA%B4%80%ED%95%99%EA%B5%90/","title":"광주인공지능사관학교"},{"content":"빅데이터란  지구상에선 지금 이순간에도 방대한 크기volumn의 다양한varity 데이터들이 빠른 속도velocity로 발생하고 있다. 빅데이터는 이를 수용하며, 데이터의 진실성veracity을 확보하고, 분석 데이터를 시각화visualization함으로써 새로운 효이기을 가져다 줄 가치value를 창출하는 것이다.\n빅데이터는 수집 \u0026gt; 적재 \u0026gt; 처리 \u0026gt; 탐색 \u0026gt; 분석 \u0026gt; 응용의 단계를 거친다.\n 빅데이터 구현기술 \r\n파일럿 프로젝트 소개 다음과 같은 데이터를 가지고 빅데이터 프로젝트를 진행한다.\n 스마트카 상태 정보 데이터셋 스마트카 운전자 운행 데이터셋 스마트카 마스터 데이터셋 스마트카 물품구매 이력 데이터셋  소프트웨어 아키텍처 \r\n파일럿 프로젝트 구축 환경 \r\n 참고 문헌 실무로 배우는 빅데이터 기술\n","date":"2021-04-13T00:00:00Z","image":"https://ssabum.github.io/content/big-data-pilot-project/big_huc3341fa433694cc25a4a023e642e485d_212847_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/big-data-pilot-project/","title":"Big data pilot project"},{"content":"가상머신 정의💻 가상 머신(Virtual Machine, VM)은 컴퓨팅 환경을 소프트웨어로 구현한 것, 즉 컴퓨터를 에뮬레이션하는 소프트웨어다. 가상머신상에서 운영체제나 응용프로그램을 설치 및 실행할 수 있다.\n시스템 가상 머신 시스템 가상 머신은 때로 하드웨어 가상 머신이라고 하며 각 운영 체제를 실행하는 가상 머신 사이의 기초가 되는 물리 컴퓨터를 다중화(multiplex)한다. 가상화를 제공하는 소프트웨어 계층은 가상 머신 모니터 또는 하이퍼바이저라고 한다. 하이퍼바이저는 순 그대로의 하드웨어 또는 호스트 운영 체제 위에서 실행할 수 있다.\n시스템 가상 머신의 주요 이점\n 여러 운영 체제를 쓰는 환경은 운영 체제가 완벽히 고립된 채로 같은 컴퓨터에서 존재할 수 있다. 가상 머신은 실제의 컴퓨터가 제공하는 것과 다른 형태의 명령어 집합 구조 (ISA)를 제공한다.  즉, 다양한 OS를 제공하기 위해 멀티부팅의 어려움을 겪지 않아도 되고 각각은 서로 독립되어 있어 서로에게 영향을 미치지 않는다. 이는 관리에 용이성을 부여하고, 외부의 위험으로부터 분리된 환경이라 다양한 테스트 환경에 적합하다. 최근에는 서버를 가상화하여 사용자들에게 대여해주는 클라우드 호스팅이 유행하고 있는데, 이도 가상화 기술의 발전의 한 갈래이다.\n프로세스 가상 머신 VM은 응용 프로그램 가상 머신이라고도 하며, 운영 체제 안에서 일반 응용 프로그램을 돌리고 단일 프로세스를 지원한다. 프로세스가 시작하고, \u0026lsquo;끝내기\u0026rsquo;되어 파괴될 때 만들어진다. 목적은 플랫폼에서 다른 플랫폼 방식으로 실행하는 프로그램을 허용하고 기초가 되는 하드웨어나 운영 체제의 상세한 부분을 가져오는 독립 프로그래밍 환경을 제공하기 위함이다.\n가상 머신이라고 하는 프로세스는 고급 프로그래밍 언어에서 높은 수준의 추출을 제공며 해석기를 사용하여 추가된다.\n이러한 종류의 가상 머신은 자바 가상 머신을 사용하여 추가되는 자바와 더불어 인기를 끌었다. 또다른 예로는, 닷넷 프레임워크가 있는데 공통 언어 런타임라고 불리는 가상 머신을 실행한다.\n \r\n","date":"2021-04-13T00:00:00Z","image":"https://ssabum.github.io/content/%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD/code_hu696a336fe623223aab73a912217f27f7_1787389_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD/","title":"가상환경"},{"content":"정보처리기사👨‍💻 과학기술정보통신부에서 주관하고 한국산업인력공단에서 시행하는 국가자격 시험으로, 소프트웨어 개발, 정보시스템의 생명주기 전반에 걸친 프로젝트 업무를 수행하는 직무로서 계획수립, 분석, 설계, 구현, 시험, 운영, 유지보수 등의 업무를 수행할 수 있는 능력을 검증하는 시험이다.\n2020년부터 NCS 표준에 맞춰 시험 과목이 필기, 실기 모두를 포함해 대폭 개편되었다. 그래서 시작된 나의 오랜 정보처리기사도전기\u0026hellip;😥\n작년에 필기를 합격했지만 실기는 떨어지면서 오는 25일 새로운 도전을 앞두고 있다. 이제부터 시작이지만\u0026hellip;\u0026ldquo;제발, 당신의 기사가 될 수 있기를\u0026hellip;\u0026rdquo;\n","date":"2021-04-12T00:00:00Z","image":"https://ssabum.github.io/content/%EB%82%B4%EA%B0%80-%EB%8B%B9%EC%8B%A0%EC%9D%98-%EA%B8%B0%EC%82%AC%EA%B0%80-%EB%90%98%EC%96%B4-%EC%A4%84%EA%B2%8C%EC%9A%94/book_hu7396fba383e6517fd1fea0f069a72db2_3435619_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%82%B4%EA%B0%80-%EB%8B%B9%EC%8B%A0%EC%9D%98-%EA%B8%B0%EC%82%AC%EA%B0%80-%EB%90%98%EC%96%B4-%EC%A4%84%EA%B2%8C%EC%9A%94/","title":"내가 당신의 기사가 되어 줄게요"},{"content":"1463번 1로 만들기 문제 보러가기\n🅰 설계   문제에서 주어진 아래의 조건에 맞추어 코드를 구현하고 카운트의 최솟값을 구하는 알고리즘을 실행시켰지만 답이 나오지 않았다\u0026hellip;\n  x가 3으로 나누어 떨어지면, 3으로 나눈다.\n  x가 2로 나누어 떨어지면, 2로 나눈다.\n  1을 뺀다.\n    다음으로 연필로 써내려가면서 규칙이 있나 찾아보았다. 개인적으로 싫어하는 방법이지만 풀 방법이 생각나지 않아 도전해 보았다\u0026hellip;\n역시, 규칙은 보이지 않았다\u0026hellip;\n  ✔ 정답 코드 구글링 N = int(input()) dp_list = [0,0,1,1] # 0 ,1, 2, 3 의 최소 수 미리 저장 for i in range(4, N + 1) : # 먼저 1을 뺏을 경우 나오는 경우의 수 저장 dp_list.append(dp_list[i-1] + 1) #2로 나누어질 경우 기존 1을 뺏을 경우의 수와 비교하여 최솟값 저장 if i % 2 == 0 : dp_list[i] = min(dp_list[i], dp_list[i//2] + 1) #3으로 나누어질 경우 기존 1을 뺏을 경우의 수와 비교하여 최솟값 저장 #여기서 2 또는 3으로 나누어질 경우 모든 경우를 봐야하므로 elif가 아닌 if로 설정 if i % 3 == 0 : dp_list[i] = min(dp_list[i], dp_list[i//3] + 1) print(dp_list[-1]) ✅ 후기   1로 만들기문제는 큰 문제를 작은 문제로 단순화시켜 해결하는 다이나믹 프로그래밍문제이다.\n따라서 어떤 수 N에 대하여 최소 경우를 알고 싶다면 기본이 되는 점화식을 만들어야 한다.\n본 문제에서는 dp[N] = min(dp[N-1], dp[N//2] , dp[N//3]) + 1으로 점화식을 만들 수 있다.\n  N-1로 시작한 경우, N//2로 시작한 경우, N//3으로 시작한 경우, 각각의 경우의 수를 찾아 최소 경우의 수를 찾으면 되는 일이다.\n  점화식으로 풀어나가는 DP문제는 익숙치 않아서 어려운 것 같다\u0026hellip;💦\n  ","date":"2021-04-12T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1463%EB%B2%88-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1463%EB%B2%88-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/","title":"백준 1463번 1로 만들기"},{"content":"1541번 잃어버린 괄호 문제 보러가기\n🅰 코드 # \u0026#39;-\u0026#39;부호로 나눠진 문자열 저장 arr = input().split(\u0026#39;-\u0026#39;) # 결과 변수 생성 result = 0 # 처음 \u0026#39;-\u0026#39;부호가 나오는 부분까지 더하기 for i in arr[0].split(\u0026#39;+\u0026#39;): result += int(i) # 그 뒤엔 다 빼주는데 \u0026#39;+\u0026#39;부호로 묶인 것도 나눠서 빼기 → -(a+b) = -a-b for i in arr[1:]: for j in i.split(\u0026#39;+\u0026#39;): result -= int(j) print(result) ✅ 후기  문제에 주어진 문자열에서 차례로 연산을 하기만 하면 되는 비교적 쉬운 문제였다고 생각했지만 중간에 한번 함정이 있어서 고민이 필요했다\u0026hellip; 문제에서 요구하는 가장 최소의 값이 나오긴 위해서는 -부호 뒤에 오는 숫자들의 값이 커야 했으며 이를 표현하기 위해 -부호 뒤의 문자열에서 +부호로 나누어 각각을 빼주는 작업을 진행하였다. 평소 슬라이싱을 주로 사용했어서 비교적 쉽게 접근할 수 있었던 것 같다. 파이썬 조아😗  ","date":"2021-04-12T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1541%EB%B2%88-%EC%9E%83%EC%96%B4%EB%B2%84%EB%A6%B0-%EA%B4%84%ED%98%B8/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1541%EB%B2%88-%EC%9E%83%EC%96%B4%EB%B2%84%EB%A6%B0-%EA%B4%84%ED%98%B8/","title":"백준 1541번 잃어버린 괄호"},{"content":"1620번 나는야 포켓몬 마스터 이다솜 문제 보러가기\n🅰 코드 # 데이터 입력 N, M = map(int,input().split()) # 포켓몬을 \u0026#39;이름:번호\u0026#39;로 딕셔너리 생성 arr = [0] dict = {} for num in range(1,N+1): monster = input().strip() arr.append(monster) dict[monster] = num # 주어진 문제에 대해 숫자인지, 문자인지 판별 후 검색 for _ in range(M): q = input().strip() if q.isalpha() : print(dict[q]) elif q.isdigit() : print(arr[int(q)]) ✅ 후기  일단 문제를 읽기 싫었다\u0026hellip;포켓몬컨셉인건 알겠는데 사설이 너무 길다\u0026hellip; 나중에 기회가 된다면 내가 직접 깔끔하고 섹시한 문제를 만들어 올릴 것이다. 문제에 대한 접근은 리스트, 딕셔너리 형태로 문제에서 주어진 데이터들을 저장한 후 검색해 출력하는 문제이다. 예전에 python 처음 배울때 알아 두었던 내장함수 덕에 쉽게 접근 할 수 있었다. 역시 기본이 튼튼해야 문제를 쉽게 해결 할 수 있다.😮  ","date":"2021-04-12T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1620%EB%B2%88-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1620%EB%B2%88-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C/","title":"백준 1620번 나는야 포켓몬 마스터 이다솜"},{"content":"1003번_피보나치 함수 문제 보러가기\n🅰 설계 t = int(input()) for i in range(t): n = int(input()) # fib(0), fib(1), tmp 설정 zero, one, tmp = 1, 0, 0 # 피보나치 수행 for _ in range(n): tmp = one one = one + zero zero = tmp # 출력 print(zero, one) ✅ 후기 // 풀이과정\n 처음 문제를 읽고 어떻게 해야할지 풀이가 떠오르지 않아 꽤나 고생했다.😥 하지만 5까지의 경우의 수를 직접 표로 그려보니 간단한 문제임을 알 수 있었다. fib(0), fib(1)의 카운트를 담을 변수를 생성하고 n이 커질수록 증가하는 규칙을 찾아서 코드로 옮겨주기만 하면 되는 문제였다.👍  // 앞으로 다짐\n 문제 풀이가 떠오르지 않을 땐 무조건 노트에 그려보자!!!  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1003%EB%B2%88-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1003%EB%B2%88-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98/","title":"백준 1003번 피보나치 함수"},{"content":"1012번_유기농 배추 문제 보러가기\n🅰 설계 import sys sys.stdin = open(\u0026#34;input.txt\u0026#34;) T = int(input()) for tc in range(1, T+1): # m: 가로길이, n: 세로길이, k: 배추개수 m, n, k = map(int, input().split()) # 입력된 데이터에 맞춰 밭 만들어 주기 field = list(list(0 for i in range(m)) for _ in range(n)) # 밭에 배추 심기 for i in range(k): x, y = map(int, input().split()) field[y][x] = 1 # 지렁이 검사 cnt = 0 # 이후 접근을 어떻게 해야할지... 🅰 모범답안 t = int(input()) dx = [1, -1, 0, 0] dy = [0, 0, -1, 1] def bfs(x, y): queue = [[x, y]] while queue: a, b = queue[0][0], queue[0][1] del queue[0] for i in range(4): q = a + dx[i] w = b + dy[i] if 0 \u0026lt;= q \u0026lt; n and 0 \u0026lt;= w \u0026lt; m and s[q][w] == 1: s[q][w] = 0 queue.append([q, w]) for i in range(t): m, n, k = map(int, input().split()) s = [[0] * m for i in range(n)] cnt = 0 for j in range(k): a, b = map(int, input().split()) s[b][a] = 1 for q in range(n): for w in range(m): if s[q][w] == 1: bfs(q, w) s[q][w] = 0 cnt += 1 print(cnt) ✅ 후기   데이터를 받아오고 기본 base에 넣어주는 부분까지는 구현했지만 bfs를 돌면서 탐색하는 것이 아직 익숙치 않아 한참을 노트와 키보드만 끄적거리고 두들기다가 문제를 해결하지 못했다.\n  이후 검색을 통해 풀이방법을 알 수 있었고 보다 많음 bfs, dfs 문제를 풀어보면서 숙달해야겠다고 느꼈다.😨\n  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1012%EB%B2%88-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1012%EB%B2%88-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/","title":"백준 1012번 유기농 배추"},{"content":"1074번_Z 문제 보러가기\n🅰 설계 import sys result = 0 def z(n, x, y): global result # 기본이 되는 탈출 조건 생성 if x == r and y == c: print(int(result)) exit(0) if n == 1: result += 1 return # 처음에 시간초과 떠서 경우의 수도 합쳐 주었다. # 하지만 나중에 알고보니 할 필요 없었다... if not (x \u0026lt;= r \u0026lt; x + n and y \u0026lt;= c \u0026lt; y + n): result += n * n return # 재귀함수 z(n / 2, x, y) z(n / 2, x, y + n / 2) z(n / 2, x + n / 2, y) z(n / 2, x + n / 2, y + n / 2) # 시간초과 안나기 위해 sys.stdin.readline사용...sibal... n, r, c = map(int, sys.stdin.readline().split(\u0026#39; \u0026#39;)) z(2 ** n, 0, 0) ✅ 후기 // 풀이과정\n  문제에 주어진 그림을 보면서 이해를 쉽게 할 수 있었다.\n  다만 요건은 시간초과였다.\n시간초과를 없애기 위해 if문을 합쳐 보면서 어떻게든 줄여보려 했지만 결과는 시관초과\u0026hellip;\n  이후 검색을 통해 sys.stdin.readline()에 대해 알게 되었고 이를 이용해 해결 할 수 있었다.\nsys.stdin.readline사용법\n  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1074%EB%B2%88-z/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1074%EB%B2%88-z/","title":"백준 1074번 Z"},{"content":"1107번_리모컨 문제 보러가기\n🅰 코드 # N: 목표로 하는 채널번호(0~500000), M: 고장난 버튼의 개수(0~10) N = int(input()) M = int(input()) # button: 숫자 버튼 / 고장난 버튼이 있으면 빼준다 button = {i for i in range(10)} if M != 0: button -= set(map(int, input().split())) # 100번에서 N번으로 +, - 버튼만 쓴 경우 cnt = abs(100 - N) # 50만 채널인데 최악의 경우를 고려할 때 # 작은수에서 +만 사용(50만)에 큰수에서 -만 사용(50만)을 더하면 100만 가지의 경우의 수가 발생 for i in range(1000000): flag = True for j in str(i): if int(j) not in button: flag = False break if flag: # button으로 접근 할 수 있는 수에다가 목표 채널의 차이(+, - 으로 이동)를 더한 값 cnt = min(cnt, len(str(i)) + abs(N-i)) print(cnt) 🅰 \u0026amp;연산자 사용 ![1107](../../../../../../../../Users/qqq96/Desktop/1107.PNG)import sys n = int(sys.stdin.readline()) m = int(sys.stdin.readline()) li = set(list(sys.stdin.readline().split())) res = abs(100-n) for i in range(1000000): ba = set(list(str(i))) le = len(str(i)) if not ba\u0026amp;li: res = min(res,le+abs(n-i)) print(res) ✅ 후기  문제를 보는 순간 별 생각 없이 brute force로 풀면 되겠지라는 생각을 가지고 문제에 주어진 대로 최대 채널 수 만큼 500000까지로 설계해 주었다. 그러나 맞았습니다!!라는 문구는 보이지 않았고 고민 끝에 1000000으로 설계해줘야 한다는 사실을 깨달았다!! 우여곡절 끝에 문제를 해결하고 다른 사람들은 어떻게 풀었는지 살펴보는 와중 \u0026amp;연산자를 이용해 비교적 짧게 구현된 코드를 발견하게 되었다. 결과가 어떻게 나올지 궁금하여 두개를 돌려보았는데 다음과 같이 나왔다.  \r\n 산술연산자와 비트연산자에서는 비트연산자의 속도가 월등히 빠른 걸로 알고 있는데 이 경우에서는 반대의 결과가 나와서 신기했다. 물론 난 아직 이런 연산자를 쓰는 것이 익숙치 못해 이해도 어렵지만, 나중에는 자유롭게 구사하는 날이 오기를\u0026hellip;  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1107%EB%B2%88-%EB%A6%AC%EB%AA%A8%EC%BB%A8/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1107%EB%B2%88-%EB%A6%AC%EB%AA%A8%EC%BB%A8/","title":"백준 1107번 리모컨"},{"content":"1260번_DFS와 BFS 문제 보러가기\n🅰 코드 N,M,V=map(int,input().split()) matrix=[[0]*(N+1) for i in range(N+1)] for i in range(M): a,b = map(int,input().split()) matrix[a][b]=matrix[b][a]=1 visit_list=[0]*(N+1) def dfs(V): visit_list[V]=1 print(V, end=\u0026#39; \u0026#39;) for i in range(1,N+1): if(visit_list[i]==0 and matrix[V][i]==1): dfs(i) def bfs(V): queue=[V] visit_list[V]=0 while queue: V=queue.pop(0) print(V, end=\u0026#39; \u0026#39;) for i in range(1, N+1): if(visit_list[i]==1 and matrix[V][i]==1): queue.append(i) visit_list[i]=0 dfs(V) print() bfs(V) ✅ 후기  문제 자체는 SSAFY교육에도 진행되었던 DFS, BFS의 가장 기본인 코드를 구현하는 것이었다. 그렇기에 어렵지는 않았지만, 궁극적인 목표는 어떤 문제에는 어떤 알고리즘으로 구현하는 것이 더 어울리는지 문제를 보고 바로 아는 것인것 같다. 그러므로 더욱 노력해야 할것 같다;;  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1260%EB%B2%88-dfs%EC%99%80-bfs/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1260%EB%B2%88-dfs%EC%99%80-bfs/","title":"백준 1260번 DFS와 BFS"},{"content":"1389번_케빈 베이컨의 6단계 법칙 문제 보러가기\n🅰 코드 from collections import deque def bfs(num, n): # 기본 base setting bacon = [0] * (n + 1) visited = [num] queue = deque() queue.append(num) while queue: # queue에서 popleft사용 k = queue.popleft() for i in relation[k]: if i not in visited: bacon[i] = bacon[k] + 1 visited.append(i) queue.append(i) return sum(bacon) # n: 유저수(2~100), m: 관계수(1~5000) n, m = map(int, input().split()) # 관계 dict생성 후 입력 relation = {i: [] for i in range(1, n + 1)} for i in range(m): a, b = map(int, input().split()) relation[a].append(b) relation[b].append(a) result = [] for num in range(1, n + 1): result.append(bfs(num, n)) # index로 최소 관계를 구하고 관계이기 때문에 1을 더해준다 print(result.index(min(result)) + 1) ✅ 후기  BFS를 이용하여 풀어내는 문제였다. 알고리즘 문제를 풀때마다 느끼는 거지만, 알고리즘 이해 자체는 어렵지 않지만 그것을 이용하여 문제를 풀어내는 것은 굉장히 어려운 것 같다;; 여담이지만 케빈 베이컨처럼 야리꾸리한 문제를 만들어서 자기이름을 붙이는 작자들은 도대체 어떤 사람들인지 궁금하다\u0026hellip;🥴  ","date":"2021-04-05T00:00:00Z","image":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1389%EB%B2%88-%EC%BC%80%EB%B9%88-%EB%B2%A0%EC%9D%B4%EC%BB%A8%EC%9D%98-6%EB%8B%A8%EA%B3%84-%EB%B2%95%EC%B9%99/boj_hu10369bab5a12b98907ee11b3810eb94f_44421_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EB%B0%B1%EC%A4%80-1389%EB%B2%88-%EC%BC%80%EB%B9%88-%EB%B2%A0%EC%9D%B4%EC%BB%A8%EC%9D%98-6%EB%8B%A8%EA%B3%84-%EB%B2%95%EC%B9%99/","title":"백준 1389번 케빈 베이컨의 6단계 법칙"},{"content":"SQL 개념  https://www.sqlitetutorial.net/\nSQL(StructuredQueryLanguage)는 관계형 데이터베이스 관리시스템(RDBMS)의데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어이다.\n SQL 문법의 세가지 종류\n DDL - 데이터 정의 언어  CREATE DROP ALTER RENAME   DML - 데이터 조작 언어  INSERT UPDATE DELETE SELECT   DCL - 데이터 제어 언어  GRANT REVOKE COMMIT ROLLBACK    Database 생성  해당하는 데이터베이스 파일이 있으면 해당DB를 콘솔로 연다.\n만약 해당하는 파일이 없으면 새로 생성하고, 해당 DB를 콘솔로 연다.\n $ sqlite3 database ex) $ sqlite3 tutorial.sqlite3 -- 1. 콘솔로 DB를 열고, sqlite\u0026gt; .databases -- 2.데이터베이스 목록을 확인한다. CSV 파일 불러오는 명령어\n 주의사항)\n.으로 시작하는 모든 명령어는 sqlite3 프로그램의 기능을 실행하는 명령어이며, SQL 문법에 속하지 않습니다.\n sqlite\u0026gt; .mode csv sqlite\u0026gt; .import 파일명.csv 테이블명 ex) sqlite\u0026gt; .import users.csv users_user 테이블 생성 및 삭제  데이터 타입의 종류는 INTEGER, TEXT, REAL, NUMERIC, BLOB 등이 존재한다.\n자세한 내용은 SQLite3 공식문서를 참조한다.\n 테이블 생성 (CREATE)\nCREATE TABLE table ( column1 datatype PRIMARY KEY, column2 datatype, ... );  INTEGER PRIMARY KEY 타입으로 컬럼 생성시 기본 rowid 를 대체함 단, PRIMARY KEY는 INTEGER 타입에서만 사용가능  데이터 타입\n NULL / INTEGER / REAL / TEXT / BLOB   INT와 INTEGER의 차이\nINT형은 산술연산이 가능하며 NULL로 초기화가 불가능하다\nINTEGER형은 산술연산이 불가능하며 NULL로 초기화가 가능하다\n 테이블 생성 with NOT NULL 조건 예시\nCREATE TABLE table ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INT NOT NULL, ... ); AUTOINCREMENT\n 이전의 삭제된 데이터의 pk는 재사용하지 않음  테이블 및 스키마 조회\nsqlite\u0026gt; .tables -- 테이블 목록 조회 sqlite\u0026gt; .schema table -- 특정 테이블 스키마 조회 테이블 제거 (DROP)\nsqlite\u0026gt; DROP TABLE classmates; sqlite\u0026gt; .tables -- 테이블 제거 확인 데이터 추가, 읽기, 수정 및 삭제 추가 (INSERT)\nINSERT INTO table (column1, column2) VALUES (value1, value2); INSERT INTO table (column1, column2) VALUES (value1, value2), (value1, value2), (value1, value2); id 스키마를 직접 작성 했을 때 데이터 추가 방법\n  모든 컬럼 작성 시\nINSERT INTO table (column1, column2) VALUES (value1, value2);   컬럼 미작성 시에는 직접 id 값 입력\nINSERT INTO table VALUES (2, value1, value2);   조회 (SELECT)\n SQL은 세미콜론(;)을 만나기 전까지 절대 실행되지 않습니다.\n따라서 아래 LIMIT 예시와 같이 들여쓰기를 비교적 자유롭게 할 수 있습니다.\n -- 모든 컬럼 가져오기 -- SELECT * FROM table; -- 특정 컬럼 가져오기 -- SELECT column1, column2 FROM table; -- LIMIT: 원하는 개수(num)만큼 가져오기 -- SELECT column1, column2 FROM table LIMIT num; -- OFFSET: 특정 위치에서부터 가져올 때 -- -- (맨 위부터 num만큼 떨어진 값부터 가져온다는 의미) SELECT column1, column2 FROM table LIMIT num OFFSET num; -- WHERE: 조건을 통해 값 가져오기 -- SELECT column1, column2 FROM table WHERE column=value; -- DISTINCT: 중복없이 가져오기 -- SELECT DISTINCT column FROM table; 삭제 (DELETE)\nDELETE FROM table WHERE condition; -- ex) DELETE FROM classmates WHERE name=\u0026#39;지연\u0026#39;; 수정 (UPDATE)\nUPDATE table SET column1=value1, column2=value2, ... WHERE condition; -- ex) -- 지연의 이름을 지수로 바꾼다고 하면 -- UPDATE classmates SET name=\u0026#39;지수\u0026#39;, address=\u0026#39;대한민국\u0026#39; WHERE name=\u0026#39;지연\u0026#39;; 예시와 함께하는 WHERE문 심화 (READ)\n-- Q.users에서 age가 30이상인 사람만 가져온다면? --  SELECT * FROM users WHERE age \u0026gt;= 30; -- Q.users에서 age가 30이상인 사람의 이름만 가져온다면? --  SELECT first_name FROM users WHERE age \u0026gt;= 30; -- Q.users에서 age가 30이상이고 성이 김인 사람의 성과 나이만 가져온다면? --  SELECT age, last_name FROM users WHERE age \u0026gt;= 30 and last_name=\u0026#39;김\u0026#39;; 심화 SQL문 Expressions  django ORM에서 aggregate와 대응\n   COUNT (레코드 값들의 개수 반환)\nSELECT COUNT(*) FROM users;   AVG (레코드 값들의 평균값 반환)\nSELECT AVG(age) FROM users WHERE age \u0026gt;= 30;   MAX (레코드 값들의 최대값 반환)\n  MIN (레코드 값들의 최소값 반환)\n  SUM (레코드 값들의 합 반환)\n  LIKE  LIKE는 두 가지 와일드 카드(언더스코어 그리고 퍼센트 기호)와 함께 동작한다.\n   _ (반드시 이 자리에 한 개의 문자가 존재해야 한다는 뜻)\n-- 20대인 사람들만 가져올 때 --  SELECT * FROM users WHERE age LIKE \u0026#39;2_\u0026#39;;   % (이 자리에 문자열이 있을 수도, 없을 수도 있다. 0개 이상이라는 뜻)\n-- 지역번호가 02인 사람만 가져올 때 --  SELECT * FROM users WHERE phone LIKE \u0026#39;02-%\u0026#39;;   두 개를 조합해서 사용할 수도 있다.\n-- 핸드폰 중간 번호가 반드시 4자리면서 511로 시작되는 사람들 --  SELECT * FROM users WHERE phone LIKE \u0026#39;%-511_-%\u0026#39;;   정렬 (ORDER BY)\nSELECT columns FROM table ORDER BY column1, column2 ASC | DESC; -- ASC: 오름차순 / DESC: 내림차순 -- -- 나이, 성 순서로 오름차순 정렬하여 상위 10개만 뽑아보면? --  SELECT * FROM users ORDER BY age, last_name LIMIT 10; GROUP BY\n 지정된 기준에 따라 행 세트를 그룹으로 결합한다.\n데이터를 요약하는 상황에서 주로 사용한다.\n django ORM에서 annotate와 대응   SELECT column1, aggregate_function(column_2) FROM table GROUP BY column1, column2; -- 성(last_name)씨가 몇 명인지 조회할 때 -- SELECT last_name, COUNT(*) FROM users GROUP BY last_name; ALTER\n 테이블명 변경  ALTER TABLE 기존테이블명 RENAME TO 새로운테이블명; 새로운 컬럼 추가  ALTER TABLE 테이블명 ADD COLUMN 컬럼명 datatype; ","date":"2021-04-04T00:00:00Z","image":"https://ssabum.github.io/content/sql%EB%AC%B8%EB%B2%95/sql_hubbf8a9fc18cf0c0587203e8c4fcd3fa5_78275_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/sql%EB%AC%B8%EB%B2%95/","title":"SQL문법"},{"content":"외장SSD?  외장하드, 즉 외장HDD는 많이들 들어보았을 것이다. 외장SSD는 HDD 대신 SSD를 사용하여 만들어낸 외장 메모리 저장장치이다. SSD는 HDD와 비교해 데이터 전송 속도가 빠르고, 전력 소모가 적으며, 플래터, 모터, 헤드 같은 부품이 없기 때문에 더 작고 얇게 제작할 수 있다.\n따라서 외장SSD 역시 단일 저장장치에서도 HDD 수준의 저장 용량을 확보할 수 있게 됐고, 입출력 인터페이스 역시 SSD의 빠른 속도를 선보이면서 휴대용 저장장치에 어울리는 방식으로 자리잡았다.\n외장SSD의 가장 큰 장점은 전송 속도다. HDD는 바늘 처럼 생긴 헤드를 플래터 위에서 직접 움직이며 데이터를 찾거나 데이터를 기록하는 반면, 반도체로 제작한 SSD는 이러한 과정이 없는 만큼 더 빠르게 데이터를 읽고 쓸 수 있다.\n 그래서 나도! 내 노트북의 용량은 SSD256GB이다. 그러나 필수 소프트웨어가 깔리고 프로그램과 파일들 몇 개 깔다보니 금방 금방 줄어들었다\u0026hellip;\n그래서 고민끝에 구매하게된 삼성 포터블 외장SSD T5 ㅎㅎ 통장 잔고가 좋지 못해 500GB짜리를 샀지만 나름 FLEX했다.\n그렇게 구매하고 배송받은 외장SSD를 연결하는 순간\u0026hellip;C tpye 연결시에 접촉 불량이 발생했다\u0026hellip;\n\r\n바로 삼성서비스센터에 무상교체를 보낸 상태이다\u0026hellip;\n빨리 정상작동되는 새걸로 받아서 가득 채워버려야지\u0026hellip;🤪\n그때부터 Big data 포스팅 시작이다!\n","date":"2021-04-04T00:00:00Z","image":"https://ssabum.github.io/content/%EC%99%B8%EC%9E%A5ssd/ssd_hu01a8af33eb5f2295d769ee49d18187fb_121432_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/%EC%99%B8%EC%9E%A5ssd/","title":"외장SSD"},{"content":"CSS  스타일, 레이아웃 등을 통해 HTML이 사용자에게 어떻게 표시 되는지를 지정하는 언어\n사용자에게 문서(HTML)를 표시하는 방법을 지정하는 언어\n CSS 구문  구문은 선택자와 함께 열린다. 스타일을 지정할 html 요소를 선택. 다음 중괄호가 있는데 이 안에는 속성과 값 쌍 형태를 가지는 하나 또는 그 이상의 선언(declaration)이 있다. 각 쌍은 우리가 선택한 요소의 속성을 지정하고 속성에 부여할 값을 지정한다.  선언문\n 속성 (Property)  사람이 읽을 수 있는 식별자로, 어떤 (글꼴, 너비, 배경색 등) 스타일 기능을 변경할지 나타냅니다.   값 (Value)  각 속성에는 값을 부여한다. 값은 어떻게 (글꼴을 이걸로, 배경 색을 저걸로 등)스타일 기능을 변경할 건지 나타낸다.    CSS 정의 방법\n Inline style 내부 참조 (Embedding style) 외부 참조 (Link style)   CSS Selector  선택자는 스타일을 지정할 웹 페이지의 HTML 요소를 대상으로 하는 데 사용\n 클래스(class) 선택자\n 클래스 선택자는 마침표( .) 문자로 시작 하며 해당 클래스가 적용된 문서의 모든 항목을 선택  아이디(id) 선택자\n 아이디 선택자는 # 문자로 시작하며 기본적으로 클래스 선택자와 같은 방식으로 사용 그러나 아이디는 문서 당 한 번만 사용할 수 있으며 요소에는 단일 id값만 적용 할 수 있다 문서에서 동일한 아이디를 여러 번 사용해도 동작하나 그렇게 하면 안된다.  결합자(combinators)\n 자손 결합자  셀렉터A  (공백) 셀렉터B 셀렉터A의 모든 후손 요소(level n) 중 셀렉터B와 일치하는 요소 선택   자식 결합자  셀렉터A \u0026gt; 셀렉터B 셀렉터A의 모든 자식 요소(level 1) 중 셀렉터B와 일치하는 요소 선택   일반 형제 결합자  셀렉터A ~ 셀렉터B 셀렉터A의 형제 요소 중 셀렉터A 뒤에 위치하는 셀렉터B 요소를 모두 선택   인접 형제 결합자  셀렉터A + 셀렉터B 셀렉터A의 형제 요소 중 셀렉터A 바로 뒤에 위치하는 셀렉터B 요소를 선택 단, A와 B 사이에 다른 요소가 존재하면 선택되지 않음    적용 우선순위\n !important  다른 사람들의 코드에서 발견할 때 그 의미를 알 수 있는 것은 좋다. 하지만 반드시 필요한 경우가 아니면 절대 사용하지 않는 것이 좋다., !important 는 cascading이 정상적으로 작동하는 방식을 변경하므로, CSS 스타일 문제를 해결하기가 어렵습니다.   inline style id 선택자  id는 대부분의 다른 선택자보다 우선순위가 높기 때문에 다루기가 어려워 질 수 있다. 대부분의 경우 id 보다는 모두 class 선택자로 작성하는 것이 좋다. 만약 문서 내 링크 이동이나 for를 사용하는 특별한 경우에만 아이디를 사용한다.   class 선택자 요소 선택자 소스 순서   CSS 단위 (상대) 크기 단위\npx\n 모니터 해상도의 한 화소인 \u0026lsquo;픽셀\u0026rsquo;을 기준 픽셀의 크기는 변하지 않기 때문에 고정적인 단위  %\n 백분율 단위 가변적인 레이아웃에서 자주 사용  em\n em은 상속의 영향 받음, rem은 최상위 요소(html)를 기준으로 결정됨. 상황에 따라 각기 다른 값을 가질 수 있다.  rem\n 최상위 요소인 html(root em)을 절대 단위를 기준으로 삼음. 상속의 영향을 받지 않음. 상속에 영향을 받지 않기 때문에 대부분의 경우 rem 을 많이 사용한다.  viewport\n (스크롤을 내리지 않은 상태에서) 웹 페이지를 방문한 유저에게 현재 보이는 웹 컨텐츠의 영역 viewport를 기준으로한 상대적인 사이즈 주로 스마트폰이나 테블릿 디바이스의 화면을 일컫는 용어로 사용된다. vw, vh  색상 표현 단위\n 색상 키워드  색상 키워드는 대소문자를 구분하지 않는 식별자로, red, blue, black처럼 특정 색을 나타낸다   RGB 색상  빨강, 초록, 파랑을 통해 특정 색을 표현 16진수 표기법이나 함수형 표기법으로 사용 a는 alpha(투명도)가 추가된 것   HSL 색상  색상, 채도, 명도를 통해 특정 색상을 표현 a는 alpha(투명도)가 추가된 것     Box Model  웹 디자인은 contents를 담을 box model을 정의하고 CSS 속성을 통해 스타일(배경, 폰트와 텍스트 등)과 위치 및 정렬을 지정하는 것.\n  모든 HTML 요소는 box 형태로 되어있다. 하나의 박스는 네 부분(영역)으로 이루어 진다.  content / padding / border / margin     Content  글이나 이미지, 비디오 등 요소의 실제 내용   Padding (안쪽 여백)  Border(테두리) 안쪽의 내부 여백 배경색, 이미지 지정 가능   Border Margin (바깥쪽 여백)  테두리 바깥의 외부 여백 배경색 지정 불가    마진 상쇄\n block의 top 및 bottom margin이 때로는 (결합되는 마진 중 크기가) 가장 큰 한 마진으로 결합(combine, 상쇄(collapsed))된다.   Display  display CSS 속성은 요소를 블록과 인라인 요소 중 어느 쪽으로 처리할지와 함께 자식 요소를 배치할 때 사용할 레이아웃을 설정한다.\n block\n 쌓이는 박스 요소는 블록 요소 상자를 생성하여 일반 흐름에서 요소 앞뒤에 줄 바꿈을 생성한다. 블록 레벨 요소안에 인라인 레벨 요소가 들어갈 수 있다.  inline\n 줄바꿈이 일어나지 않는 행의 일부 요소 content 너비만큼 가로 폭을 차지 width, height, margin-top, margin-bottom을 지정할 수 없음 상하 여백은 line-height로 지정  inline-block\n inline 처럼 텍스트 흐름대로 나열, block처럼 박스 형태이기 block 속성 사용가능  none\n 해당 요소를 화면에서 사라지게 하며 요소의 공간조차 사라지게 한다. visibility: hidden;은 해당 요소를 화면에서 사라지게는 하나 공간은 사라지지 않는다.   Position 박스의 위치 속성 \u0026amp; 값\n position  static / absolute / relative / fixed z-index    기본 개념\n static (기본 위치)  모든 태그의 기본 태그의 default 값   relative (상대 위치)  기본 위치(static)를 기준으로 좌표 속성을 사용해 위치 이동   absolute (절대 위치)  static 이 아닌 부모/조상 요소를 기준으로 좌표 속성 만큼 이동 부모 요소를 찾아가고 나아가 없다면 body에 붙는다.   fixed (고정 위치)  부모/조상 요소와 관계없이 브라우저의 viewport를 기준으로 좌표 속성 만큼 이동 스크롤을 내리거나 올려도 화면에서 사라지지 않고 항상 같은 곳에 위치    absolute\n absolute는 원래 위치해 있었던 과거 위치에 있던 공간은 더 이상 존재하지 않는다는 점이 특징이다. 즉, 다른 모든 것과는 별개로 독자적인 곳에 놓이게 된다. 대체 언제 쓸까?  페이지의 다른 요소의 위치와 간섭하지 않는 격리된 사용자 인터페이스 기능을 만들 수 있다. 팝업 정보 상자 및 제어 메뉴, 롤오버 패널, 페이지 어느 곳에서나 끌어서 놓기할 수 있는 유저 인터페이스 페이지 등     참고문헌 https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors\nhttps://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance\nhttps://developer.mozilla.org/ko/docs/Web/CSS/inheritance\nhttps://developer.mozilla.org/ko/docs/Web/HTML/Block-level_elements\nhttps://developer.mozilla.org/ko/docs/Web/HTML/Inline_elements\nhttps://developer.mozilla.org/ko/docs/Web/CSS/display\nhttps://docs.emmet.io/cheat-sheet/\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/css%EA%B8%B0%EC%B4%88/css_hu42497fb400a464be61c8fe27b05f0811_45708_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/css%EA%B8%B0%EC%B4%88/","title":"CSS기초"},{"content":"CSS Layout  웹페이지에 포함되는 요소들을 어떻게 취합하고 그것들이 어느 위치에 놓일 것인지를 제어한다.\n float  한 요소(element)가 정상 흐름(normal flow)으로부터 빠져 텍스트 및 인라인(inline) 요소가 그 주위를 감싸 자기 컨테이너의 좌,우측을 따라 배치되어야 함을 지정한다.\n clearfix\n  float 요소와 다른 텍스트가아닌 block 요소간의 레이아웃 깨짐을 막기 위해 다음과 같이 작성한다.\n/* float 속성을 적용한 요소의 부모요소에 적용한다. */ /* 부모 태그 다음에 가상 요소(::after)로 내용이 빈(content:\u0026#34;\u0026#34;) 블럭(display: block;)을 만들고 */ /* 이 가상요소는 float left,right(both)를 초기화 한다는 뜻 */ .clearfix::after { content: \u0026#34;\u0026#34;; display: block; clear: both; }   정리\n flexbox 및 그리드 레이아웃과 같은 기술이 나오기 이전에 float는 열 레이아웃을 만드는데 사용되었다. mdn에서는 더 새롭고 나은 레이아웃 기술이 나와있으므로 레거시 레이아웃 기술로 분류해놓기도 했다. 결국 원래 텍스트 블록 내에서 float 이미지를 위한 역할로 돌아간 것이다. 여전히 사용하는 경우도 있다. (ex. naver nav bar)   flexbox  일명 flexbox라 불리는 Flexible Box module은 flexbox 인터페이스 내의 아이템 간 공간 배분과 강력한 정렬 기능을 제공하기 위한 1차원 레이아웃 모델로 설계되었다.\n웹페이지의 컨테이너에 아이템의 폭과 높이 또는 순서를 변경해서 웹페이지의 사용 가능한 공간을 최대한 채우고 이를 디바이스 종류에 따라 유연하게 반영하도록 하는 개념\n 핵심 개념\n 요소  flex container flex items   축  maix axis (주축) cros axis (교차축)    flex container\n flexbox 레이아웃을 형성하는 가장 기본적인 모델 flexbox가 놓여있는 영역 flex 컨테이너를 생성하려면 영역 내의 컨테이너 요소의 display 값을 flex 혹은 inline-flex로 지정 flex 컨테이너를 선언시 아래와 같이 기본 값이 지정  item은 행으로 나열 item은 주축의 시작 선에서 시작 item은 교차축의 크기를 채우기 위해 늘어남 flex-wrap 속성은 nowrap으로 지정    Tip !\rjustify - main axis\ralign - cross axis\rcontent - 여러 줄\ritems - 한 줄\rself - 개별 요소\rflex-direction\n 쌓이는 방향 설정 (main-axis 의 방향만 바뀜. flex 는 single-direction layout concept 이기 때문)\n  row (기본값)  가로로 요소가 쌓임 row 는 주축의 방향을 왼쪽에서 오른쪽으로 흐르게 한다.   row-reverse column  세로로 요소가 쌓임 column 은 주축의 방향을 위에서 아래로 흐르게 한다.   column-reverse  flex-wrap\n item들이 강제로 한 줄에 배치 되게 할 것인지 여부 설정\n  nowrap (기본 값)  모든 아이템들 한 줄에 나타내려고 함 (그래서 자리가 없어도 튀어나옴)   wrap : 넘치면 그 다음 줄로 wrap-reverse : 넘치면 그 윗줄로 (역순)  flex-flow\n flex-direction 과 flex-wrap 의 shorthand\n flex-flow: row nowrap; justify-content\n main axis 정렬\nflex-direction: row 기준으로 작성됨\n  flex-start (기본 값)  시작 지점에서 쌓임(왼쪽 → 오른쪽)   flex-end  쌓이는 방향이 반대 (flex-direction: row-reverse 와는 다르다. 아이템의 순서는 그대로 정렬만 우측에 되는 것.)   center space-between  좌우 정렬 (item 들 간격 동일)   space-around  균등 좌우 정렬 (내부 요소 여백은 외곽 여백의 2배)   space-evenly  균등 정렬 (내부 요소 여백과 외각 여백 모두 동일)    align-items\n cross axis 여러 줄 정렬\nflex-direction: row 기준으로 작성됨\n  stretch (기본 값)  컨테이너를 가득 채움   flex-start  위   flex-end  아래   center baseline  item 내부의 text에 기준선을 맞춤    align-self\n align-items 와 동일 (단, 개별 item 에 적용)\n  auto (기본 값) flex-start flex-end center baseline stretch  부모 컨테이너에 자동으로 맞춰서 늘어난다. (Stretch \u0026lsquo;auto\u0026rsquo;-sized items to fit the container)    order\n 기본 값 : 0 작은 숫자 일수록 앞(왼쪽)으로 이동.  flex-grow\n 기본 값 : 0 주축에서 남는 공간을 항목들에게 분배하는 방법 각 아이템의 상대적 비율을 정하는 것이 아님 음수는 불가능   Bootstrap  The most popular HTML, CSS, and JS library in the world.\n   트위터에서 시작된 오픈 소스 프론트엔드 라이브러리\n  웹 페이지에서 많이 쓰이는 요소를 거의 전부 내장하고 있다.\n  디자인을 할 시간이 크게 줄어들고, 여러 웹 브라우저를 지원하기 위한 크로스 브라우징에 골머리를 썩일 필요가 없다.\n  웹 브라우저 크기에 따라 자동으로 정렬되는 \u0026ldquo;그리드 시스템\u0026quot;을 지원하며,\n  \u0026ldquo;one souce multi use\u0026rdquo; → 반응형 웹 디자인을 추구한다.\n  Responsive web design\n layout은 방문자의 화면 해상도를 고려하여야 한다. 스마트폰이나 태블릿 등 모바일 기기는 화면이 작기 때문에 가독성에 더욱 신경써야 한다. 보통 웹사이트가 축소되어 가로 스크롤 없이 콘텐츠를 볼 수 있으나 글자가 너무 작아지기 때문이다. 데스크탑용, 테블릿용, 모바일용 웹사이트를 별도 구축할 수도 있지만 One Source Multi Use의 관점에서 올바른 해결책은 아니다. 반응형 웹 디자인(Responsive Web Design)은 화면 해상도에 따라 가로폭이나 배치를 변경하여 가독성을 높여 이러한 문제를 해결한다. 즉, 하나의 웹사이트를 구축하여 다양한 디바이스의 화면 해상도에 최적화된 웹사이트를 제공하는 것이다.   Bootstrap Grid System Grid System\n 부트스트랩의 grid system 은 containers, rows 그리고 columns 를 사용해서 컨텐츠를 레이아웃하고 정렬한다. 모바일 우선 flexbox grid 를 사용하여 12개의 column 시스템을 가지고 있다. 왜 12 columns 일까 ?  12는 약수가 가장 많기 때문에 한 줄에 표시할 수 있는 종류가 제일 많다.   다음과 같은 구조로 사용한다.  .container \u0026gt; .row \u0026gt; col-*    .row\n row 는 columns 의 wrapper 이다. 각 column 에는 공간 사이를 제어하기 위한 좌우 padding 값이 있는데 이를 gutter 라고도 한다.  row 의 margin 값과 gutter 를 제거하려면 .row 에 .no-gutters class 를 사용한다.    .col / .col-*\n column class 는 row 당 가능한 12개 중 사용하려는 columns 수를 나타낸다. columns 너비는 백분율로 설정 되므로 항상 부모 요소를 기준으로 유동적으로 크기가 조정된다. grid layout 에서 내용은 반드시 columns 안에 있어야 하며 그리고 오직 columns 만 row 의 바로 하위 자식 일 수 있다.  offset\n offset-* 은 지정한 만큼의 column 공간을 무시하고 다음 공간부터 컨텐츠를 적용한다.  Nesting\n .row \u0026gt; .col-* \u0026gt; .row \u0026gt; .col-* 의 방식으로 중첩 사용 가능하다.  Grid breakpoints\n 부트스트랩 grid system 은 다양한 디바이스에서 적용하기 위해 특정 px 조건에 대한 지점을 정해 두었는데 이를 breakpoints 라고 한다. 부트스트랩은 대부분의 크기를 정의하기 위해 em 또는 rem 을 사용하지만 px 는 그리드 breakpoint 에 사용된다. (뷰포트 너비가 픽셀 단위이고 글꼴 크기에 따라 변하지 않기 때문)   마무리  각각의 기술은 저마다 용도가 있고, 장단점이 있으며, 독립적인 용도를 갖추도록 설계된 기술은 없다.\n특정 상황에 어떤 기술이 가장 적합한 도구가 될 것인지 파악하는 데에는 많은 경험이 필요하다.\n  참고문헌 https://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Introduction\nhttps://developer.mozilla.org/ko/docs/Web/CSS/float\nhttps://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Floats\nhttps://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Flexbox\nhttps://developer.mozilla.org/ko/docs/Web/CSS/CSS_Flexible_Box_Layout/Flexbox%EC%9D%98_%EA%B8%B0%EB%B3%B8_%EA%B0%9C%EB%85%90\nhttps://css-tricks.com/snippets/css/a-guide-to-flexbox/\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/css%EA%B8%B0%EC%B4%88-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/css_hu42497fb400a464be61c8fe27b05f0811_45708_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/css%EA%B8%B0%EC%B4%88-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/","title":"CSS기초 레이아웃"},{"content":"Django wep programming  파이썬으로 만들어진 무료 오픈소스 웹 애플리케이션 프레임워크\n즉, 쉽고 빠르게 웹사이트를 개발할 수 있도록 돕는 구성요소로 이루어진 웹 프레임워크\n여기서 프레임워크란, 애플리케이션 개발에 바탕이 되는 템플릿과 같은 역할을 하는 클래스들과 인터페이스의 집합\n 기본 생성 파일  mysite: 프로젝트를 담는 공간 manage.py: 프로젝트와 다양한 방법으로 상호작용 하는 커맨드라인의 유틸리티 init.py: 파이썬으로 하여금 이 디렉토리를 패키지처럼 다루라고 알려주는 용도의 빈 파일 setting.py: 현재 프로젝트의 환경 및 구성을 저장 urls.py: 현재 프로젝트의 URL선언을 저장 wsgi.py: 현재 프로젝트를 서비스하기 위한 WSGI 호환 웹 서비의 진입점  django cycle \r\ndjango 명령어 # 프로젝트 생성 $ django-admin startproject 프로젝트명 # 앱 생성 $ python manage.py startapp 앱명 # 서버가 제대로 동작하는지 로컬에서 확인, http://127.0.0.1:8000/에서 출력 $ python manage.py runserver # INSTALLED_APPS 설정을 탐색하여 데이터베이스 생성 $ py manage.py migrate # 데이터베이스에 테이블을 생성할 수 있도록 설계도를 작성 $ py manage.py makemigrations polls # 데이터베이스에 실제 테이블을 생성 $ py manage.py migrate # API를 사용하기 위해 $ py manage.py shell # 생성한 모델을 추가 $ from polls.models import Choice, Question # 관리자 생성 # winpty: windows 콘솔과 통신이 가능한 인터페이스를 제공하는 windows software package $ winpty python manage.py createsuperuser 프로젝트와 앱  앱: 특정한 기능을 수행하는 웹 어플리케이션, 다수의 프로젝트에 포함될 수 있다. 프로젝트: 특정 웹 사이트를 위한 앱들과 각 설정들을 한데 묶어놓은 것, 다수의 앱을 포함할 수 있다.  작동 순서  view 내용 입력 뷰를 호출하기 위한 연결 url 생성을 위해 urls.py 파일 생성 최상위 URLconf에서 생성한 urls.py모듈을 바라보게 설정  이때 include()함수는 다른 URLconf드을 참조할 수 있도록 도움 만약 127.0.0.1/polls/이라는 url을 받으면 파싱을 하여 분기, 해당 path인 polls을 잡아내고 연결을 시켜줌 연결된 urls.py에서 path를 통해 view로 연결 view내부의 함수를 통해 response를 클라이언트에게 전달    데이터베이스 django는 기본적으로 SQLite를 사용하도록 구성되어 있으며, 다른 데이터베이스를 사용하고 싶다면 setting.py파일을 수정해서 사용할 수 있다.\nINSTALLED_APPS django를 사용할 때 기본적으로 딸려 오는 앱으로 추가적으로 모델을 사용하기 위해 추가하면 된다.\n admin: 관리용 사이트 auth: 인증시스템 contenttypes: 컨텐츠 타입을 위한 프레임워크 sessions: 세션 프레임워크 messages: 메세징 프레임워크 staticfiles: 정적 파일을 관리하는 프레임워크  모델 부가적인 메타데이터를 가진 데이터베이스의 구조(layout)를 지칭\n 모델은 데이터에 관한 단 하나의, 가장 확실한 진리의 원천\n이 원칙에 따라 데이터 모델을 한곳에서 정의하고, 이것으로부터 자동으로 뭔가를 유도하는 것이 목표\n API 개발자가 필요로하는 데이터를 뽑아낼 수 있도록 하는 함수, 또는 서버에게 데이터베이스에게 데이터를 입력할 수 있도록 하는 함수\nAdmin 페이지 사이트 관리를 위한 관리자 전용 페이지로 django는 자동으로 제공\nssafy class 중요 urls.py: 주소 관리\nviews.py: 페이지 관리\nmodels.py: 데이터베이스 관리\n실행순서  installed_apps: 앱 등록 project/urls.py: path 등록 app/views.py: 요청 수신/반환 함수 작성 templates/index.html: templates 작성  ","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/django-%EA%B8%B0%EB%B3%B8/icon_hu080e9ab032fb83faecb2fd0168b96dc6_15390_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/django-%EA%B8%B0%EB%B3%B8/","title":"Django 기본"},{"content":"HTML  \u0026ldquo;웹 컨텐츠의 의미와 구조를 정의할 때 사용하는 언어\u0026rdquo;\n HTML 기초 Hyper\n 텍스트 등의 정보가 동일 선상에 있는 것이 아니라 다중으로 연결되어 있는 상태  Hyper Text\n 참조(하이퍼링크)를 통해 사용자가 한 문서에서 다른 문서로 즉시 접근 할 수 잇는 텍스트 하이퍼 텍스트가 쓰인 기술등 중 가장 중요한 2가지 (http, html)  Markup Language\n 특정 텍스트에 역할을 부여하는, 따라서 \u0026ldquo;마크업을 한다\u0026rdquo; 라고 하는 건 제목이 제목이라하고 본문이 본문이라고 마킹을 하는 것 ex) h1 tag는 단순히 글자가 커지는 것이 아니라 의미론적으로 그 페이지에서 가장 핵심 주제를 의미하는 것  HTML 기본 구조 DOM\n DOM은 문서의 구조화된 표현(structured representation)을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 도움 DOM은 동일한 문서를 표현하고, 저장하고, 조작하는 방법을 제공 웹 페이지의 객체 지향 표현  요소 (Element)\n HTML 요소는 시작 태그와 종료 태그 그리고 태그 사이에 위치한 내용으로 구성  태그(Element, 요소)는 컨텐츠(내용)를 감싸서 그 정보의 성격과 의미를 정의 한다.   내용이 없는 태그들  br, hr, img, input, link, meta   요소는 중첩(nested)될 수 있다.  이러한 중첩들로 하나의 문서를 완성해 나간다. 그리고 항상 열고 닫는 태그 쌍이 잘 맞는지 잘 봐야한다. HTML은 오류를 뿜지 않고 그냥 레이아웃이 깨져버리기 때문에 어떤 면에서는 친절하게 오류 띄워주고 어디 틀렸는지 알려주는 프로그래밍 보다 디버깅이 힘들다.    속성 (Attribute)\n 속성(Attribute)은 태그의 부가적인 정보가 들어온다. 요소는 속성을 가질 수 있으며 요소에 추가적 정보(이미지 파일의 경로, 크기 등)를 제공한다. 요소의 시작 태그에 위치해야 하며 이름과 값의 쌍을 이룬다. 태그와 상관없이 사용 가능한 속성들(html global attribute)도 있다.  시맨틱 태그  브라우저, 검색엔진, 개발자 모두에게 콘텐츠의 의미를 명확히 설명하는 태그\n 장점\n 읽기 쉬워진다. (개발자)  개발자가 의도한 요소의 의미가 명확히 드러나고 있다.이것은 코드의 가독성을 높이고 유지보수를 쉽게 한다.   접근성이 좋아진다. (검색엔진 및 보조기술 → 시력장애용 스크린리더 → 더 나은 경험 제공)  HTML 문서는 html 언어 + 사람이 읽을 수 있는 content의 조합인데, 검색 엔진은 HTML 코드만 잘 읽는다. 그래서 이 검색 엔진이 HTML을 잘 이해하도록 시맨틱 태그 사용이 권장되고, 그러면 검색 엔진도 무슨 내용인지 이해할 수 있게 된다.    시맨틱 웹\n 웹에 존재하는 수많은 웹페이지들에 메타데이터를 부여하여, 기존의 단순한 데이터 집합이었던 웹페이지를 \u0026lsquo;의미\u0026rsquo;와 \u0026lsquo;관련성\u0026rsquo;을 가지는 거대한 데이터베이스로 구축하고자 하는 발상.   참고 문헌 https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Getting_started\nhttps://developer.mozilla.org/ko/docs/Web/HTML/Global_attributes\nhttps://developer.mozilla.org/ko/docs/Glossary/Semantics\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/html%EA%B8%B0%EC%B4%88/html_hu5ae5770cb34043b5079993437294d24c_21751_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/html%EA%B8%B0%EC%B4%88/","title":"HTML기초"},{"content":"Object-Oriented Programming의 약자로 객체지향프로그래밍이다.\n쉽게 말해 주어 동사 형태로 프로그래밍하는 것!\n1. 절차 지향 프로그래밍 물이 위에서 아래로 흐르듯 순차적인 처리가 중요합니다. 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다.\n2. 객체 지향 프로그래밍 실제 세계를 모델링해 소프트웨어를 개발하는 방법입니다. 객체지향 프로그래밍에서는 데이터와 절차를 하나의 덩어리로 묶어서 생각합니다. 마치 컴퓨터 부품을 하나씩 구매해 컴퓨터를 조립하는 것과 같은 방식입니다.\n\r\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/oop/oop_hu77071c61b22f59609cf235d78dd545c9_23490_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/oop/","title":"OOP"},{"content":"SQLD란 무엇일까? 한국데이터산업진흥원에서 주관하는 시험으로, Structured Query Language Developer의 줄임말로 데이터베이스 SQL국가공인 자격증이다😎\n저번주 올해 첫 시험인 03.20(토) 시험을 접수했고 앞으로 3주 가량 남은 상황, 오늘부터 SQLD 공부를 시작한다!!\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/sqld/sql_hubbf8a9fc18cf0c0587203e8c4fcd3fa5_78275_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/sqld/","title":"SQLD"},{"content":"국내 IT기업 기술 블로그 1) Naver D2\n· 국내 최대 포털사이트 네이버의 기술블로그 Naver D2입니다. NAVER 개발자들이 직접 정리한 실전 개발 경험과 지식, 주요 개발자 행사 소식과 후기를 업로드합니다.\n2) kakao Tech\n· 카카오의 기술 블로그로, 카카오 서비스를 만드는 개발자들의 실제 개발 사례를 중심으로 기술과 노하우를 전달합니다. 이벤트와 오픈소스, 채용 정보도 확인할 수 있습니다.\n3) 쿠팡 기술블로그\n· 국내 온라인 쇼핑 사이트 쿠팡의 기술블로그입니다. 쿠팡 글로벌 개발팀이 쿠팡을 만들고 진화시키면서 배운 점과 얻은 교훈을 비롯해 다양한 테크 관련 이야기를 전달합니다.\n4) WATCHA 팀 블로그\n· 국내 OTT 서비스의 대표 주자 왓챠의 팀 블로그입니다. 개발, 테크, 기술이 가장 메인 주제입니다. 종종 왓챠팀의 문화, 브랜딩 소식을 올리기도 합니다.\n5) 당근마켓 기술 블로그\n· 2020년 6월 누적 2천만 다운로드, 월 순 방문자수 800만 명을 돌파한 중고거래 앱 서비스 당근마켓의 팀 블로그입니다. 개발, 테크 관련 콘텐츠가 주를 이룹니다.\n6) 우아한형제들 기술 블로그\n· 국내 대표 푸드 테크 서비스 배달의민족을 운영하는 우아한형제들의 기술 블로그입니다. 우아한 형제들의 대표적 개발자 양성 프로그램인 우아한 테크코스의 후기 포스팅이 올라오기도 합니다.\n7) LINE Engineering\n· 글로벌 메신저 서비스 LINE이 운영하는 기술 블로그입니다. 블로그 포스팅과 더불어 오픈소스와 채용정보도 확인하실 수 있습니다.\n8) 마켓컬리 Tech Blog\n· 코로나19 사태로 인해 최근 가장 주목 받는 기업 중 하나가 된 푸드 테크 기업 마켓컬리의 기술 블로그입니다.\n9) 뱅크샐러드 기술 블로그\n· 금융플랫폼 서비스 뱅크샐러드의 공식 블로그입니다. 기술, 개발, 테크 관련 콘텐츠가 주를 이루고 있습니다.\n10) NHN 기술블로그 TOAST Meetup!\n· 종합 IT 기업 NHN의 기술 블로그입니다. 블로그 메인화면에서 기술을 공유하고 함께 성장해가는 개발 문화를 추구한다고 밝히고 있습니다.\n11) 강남언니 공식 블로그\n· 미용 의료 분야의 Tech 기업 강남언니의 공식 블로그입니다. 기술, 테크 주제의 콘텐츠와 함께 브랜드, 조직문화에 대해서도 공유합니다.\n12) Delivery Tech Korea\n· 푸드 테크 기업 딜리버리코리아의 기술 블로그입니다. 요기요\u0026amp;배달통 서비스 개발 및 협업 방식과 문화에 대한 포스팅을 업로드합니다.\n13) HYPER CONNECT 기술 블로그\n· 실시간 영상채팅 서비스 아자르(Azar)를 제작한 비디오 및 인공지능 기술 기반의 영상 기술 기업 하이퍼커넥트의 기술 블로그입니다.\n14) Spoqa 기술 블로그\n· 매장 마케팅 솔루션 도도 포인트를 서비스하는 스포카의 기술 블로그입니다. 블로그 소개에서 건강한 오픈소스 커뮤니티 형성을 위해 배우고 개선한 것들을 오픈소스로 공개한다고 말합니다.\n15) 쏘카 기술블로그\n· 그린카와 더불어 국내 대표 카셰어링 서비스 쏘카의 기술 블로그입니다.\n16) 리디 Tech blog\n· 리디북스를 비롯해, 리디셀렉트, 리디페이퍼, 아웃스탠딩 등의 콘텐츠 플랫폼 서비스를 제공하는 리디코퍼레이션의 기술 블로그입니다.\n17) 이스트소프트 AI PLUS TECH\n· 알집, 알약으로 익숙한 이스트소프트의 기술 블로그입니다. 주로 AI 주제의 콘텐츠를 포스팅합니다.\n18) 플랫팜 팀 블로그\n· 이모티콘 콘텐츠 플랫폼이자 메신저 기업을 대상으로 하는 B2B 솔루션 Mojitok을 서비스하는 플랫팜의 팀 블로그입니다.\n19) 레진 기술 블로그\n· 웹툰 서비스인 레진코믹스를 제작하는 레진엔터테인먼트가 운영하는 기술 블로그입니다.\n20) 플라네타리움 엔지니어링 스낵\n· 게임에 특화된 오픈 소스 P2P 라이브러리 Libplanet과, 중앙 서버 없는 온라인 게임 나인 크로니클을 제작하는 테크 기업, 플라네타리움의 기술 블로그입니다.\n국내 기술 콘텐츠 플랫폼 1) Velog\n· 개인 기술 블로그와 최신 콘텐츠를 찾을 수 있는, 기술 블로그 콘텐츠 큐레이션 플랫폼입니다.\n2) GeekNews\n· 개발, 기술, IT 소식, 스타트업 등을 전하는 뉴스 큐레이션 플랫폼입니다. 해외 기술 동향과 관련된 소식을 확인하실 수 있습니다.\n3) 개발자스럽다\n· 개발자를 위한 주요 소식과 뉴스레터를 공유하는 사이트입니다.\n4) 44BITS\n· 당근마켓 개발자를 비롯해, 총 5명의 개발자가 프로그래밍과 클라우드를 주요 주제로 운영하는 기술 블로그입니다.\n5) 프로그래머스\n· 기술 중심 개발자 채용 플랫폼입니다. 기술 블로그는 아니지만 개발, IT 직군의 주요 채용 공고를 확인하실 수 있습니다.\n해외 IT 기업 기술 블로그 1) Facebook Engineering\n· 세계 최대 소셜 미디어 페이스북의 기술 블로그입니다. 인스타그램도 검색하면 기술 블로그는 나오지만 2019년 이후로 업데이트가 되지 않고 있습니다.\n2) Amazon Alexa\n· 세계 최대 이커머스 플랫폼 아마존의 기술 블로그입니다. Alexa는 아마존이 개발한 인공지능 플랫폼의 이름입니다.\n3) Apple Developer\n· 앱스토어 내 앱 제작 등 애플 관련 서비스를 사용해야 하는 개발자들을 위해 만들어진 애플의 기술 블로그입니다. 애플 관련 주요 소식을 전달하는 뉴스룸에 더 가깝습니다.\n4) THE NETFLIX TECH BLOG\n· 세계적인 동영상 스트리밍 서비스 기업 넷플릭스의 기술 블로그입니다.\n5) Google Devlopers\n· 세계 최대 테크 기업 구글의 기술 블로그입니다. 구글과 관련한 기술, 뉴스, 업데이트 내용을 주로 다룹니다.\n6) Microsoft Tech Community\n· 세계 최대 소프트웨어 기업 마이크로소프트도 기술 블로그를 운영하고 있습니다. 개발자들끼리 궁금한 점을 묻고 답할 수 있는 테크 커뮤니티도 잘 형성되어 있습니다.\n7) Linkedin Engineering\n· 채용 중심의 소셜 미디어 링크드인의 기술 블로그입니다.\n8) Slack Engineering\n· 세계 대 협업 메신저인 슬랙의 기술 블로그입니다.\n9) Spotify Engineering\n· 머지 않은 미래에 한국 출시가 예상되는, 음원 스트리밍 플랫폼 스포티파이의 기술 블로그입니다.\n10) PayPal Engineering Blog\n· 미국의 간편 결제 서비스 페이팔의 기술 블로그입니다.\n11) ebay Tech Blog\n· 국내에서는 G마켓, 옥션, G9를 서비스 중인 세계적인 오픈마켓 이베이의 기술 블로그입니다.\n12) Twitter Engineering\n· 페이스북과 더불어 대표적 소셜 미디어 중 하나인 트위터의 기술 블로그입니다.\n13) RIOT GAMES TECHBLOG\n· 롤이라는 이름으로 널리 알려진 인기 게임, 리그 오브 레전드를 서비스하는 라이엇 게임즈의 기술 블로그입니다.\n14) Figma Blog Engineering\n· 스케치의 뒤를 이어 최근 많은 주목을 받고 있는 웹/앱 디자인 협업툴 피그마의 기술 블로그입니다.\n15) Airbnb Engineering \u0026amp; Data Science\n· 숙박 공유 플랫폼 에어비앤비의 기술 블로그입니다. 블로그 이름에서 알 수 있든 데이터 사이언스 관련 포스팅이 많습니다.\n16) Zoom Developer Blog\n· 코로나19 사태의 수혜를 받은 대표적 기업, 화상회의 플랫폼 줌의 기술 블로그입니다.\n17) Pinterest Engineering\n· 디자이너와 그림에 관심 있는 분들의 필수 사이트, 핀터레스트의 기술 블로그입니다.\n18) Uber Engineering\n· 차량 공유 서비스 (Rider Sharing) 우버의 기술 블로그입니다.\n19) Google Play Apps \u0026amp; Games\n· 구글 플레이 관련 기술적 팁, 트렌드, 지식을 제공하는 구글 플레이 기술 블로그입니다.\n20) Drpbox Tech\n· 웹 기반 파일 공유 서비스 드롭박스의 기술 블로그입니다.\n","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/%EA%B8%B0%EC%88%A0%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%86%8C%EA%B0%9C/tech_hu9335188f5464ae1366b02b4610e0ffc3_286791_120x120_fill_q75_box_smart1.jpg","permalink":"https://ssabum.github.io/content/%EA%B8%B0%EC%88%A0%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%86%8C%EA%B0%9C/","title":"기술블로그 소개"},{"content":"Algorithm기본 이론에 대해 알아보자\nBig-Oh Notation 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시\n\r\n배열 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사요하는 자료구조\n완전검색(Brute-force) 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법\n정렬 알고리즘 학습한 정렬 알고리즘의 특성\n\r\n너비우선탐색(BFS) 👉 큐(queue) 매 단계에서 가능한 경우의 수들을 모두 확인하면서 탐색, 트리를 넓히면서 탐색하는 알고리즘\n\r\n깊이우선탐색(DFS) 👉 스택(stack) 여러 경우의 수 중 하나를 선택, 선택 후 가능한 여러 경우의 수 중 하나를 선택\n매 단계에서 가능한 것 중 일단 하나를 선택해 끝을 볼 때까지 확인\n\r\n스택(Stack) 자료를 차곡차곡 쌓는 것\nLast In First Out 👉 후입선출\n\r\n큐(Queue) 줄을 서서 기다리는 것\nFirst In First Out 👉 선입선출\n\r\n구현 순차 DFS - 깊이우선탐색 \r\n\r\n  루트 노드 (시작점) 인 A 를 스택에 넣습니다.\n  A 를 Pop 하면서 Expand 합니다. 즉, A 는 지우고 A 의 자식인 B, C, D 를 스택에 넣습니다.\n  스택의 맨 위에 있는 B 를 Pop and Expand 합니다. 즉, B 는 지우고 B 의 자식인 E 를 스택에 넣습니다.\n  스택의 맨 위에 있는 E 를 Pop and Expand 합니다. 즉, E 는 지우고 E 의 자식인 I, J 를 스택에 넣습니다.\n  스택의 맨 위에 있는 I 를 Pop and Expand 합니다. 이 때, I 는 자식이 없으므로 (끝에 도달했으므로) 스택에 넣을 것이 없습니다.\n  스택의 맨 위에 있는 J 를 Pop and Expand 합니다. 이 때, J 또한 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택의 맨 위에 있는 C 를 Pop and Expand 합니다. 즉, C 는 지우고 C 의 자식인 F 를 스택에 넣습니다.\n  스택의 맨 위에 있는 F 를 Pop and Expand 합니다. 이 때, F 는 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택 맨 위에 있는 D 를 Pop and Expand 합니다. 즉, D 는 지우고 D 의 자식인 H, K 를 스택에 넣습니다.\n  스택의 맨 위에 있는 G 를 Pop and Expand 합니다. 이 때, G 는 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택의 맨 위에 있는 H 를 Pop and Expand 합니다. 이 때, H 는 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택의 맨 위에 있는 K 를 Pop and Expand 합니다. 이 때, K 는 자식이 없으므로 스택에 넣을 것이 없습니다.\n  스택이 비었습니다. 이 말은 모든 노드를 탐색했다는 뜻이죠!\n  BFS - 너비우선탐색 \r\n\r\n  루트 노드 (시작점) 인 A 를 큐에 넣습니다.\n  A를 Dequeue 하면서 Expand 합니다. 즉, A 는 지우고 A 의 바로 다음 자식인 B, C, D를 큐의 오른쪽에 넣습니다.\n  큐의 맨 왼쪽에 있는 B 를 Dequeue and Expand 합니다. 즉, B 는 지우고 B 의 바로 다음 자식인 E 만 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 C 를 Dequeue and Expand 합니다. 즉, C 는 지우고 C 의 바로 다음 자식인 F 를 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 D 를 Dequeue and Expand 합니다. 즉, D 는 지우고 C 의 바로 다음 자식인 G, H 를 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 E 를 Dequeue and Expand 합니다. 즉, E 는 지우고 E 의 바로 다음 자식인 I, J 를 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 F 를 Dequeue and Expand 합니다. 이 때, F 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐의 맨 왼쪽에 있는 G 를 Dequeue and Expand 합니다. 이 때, G 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐의 맨 왼쪽에 있는 H 를 Dequeue and Expand 합니다. 즉, H 는 지우고 H 의 바로 다음 자식인 K 를 큐에 넣습니다.\n  큐의 맨 왼쪽에 있는 I 를 Dequeue and Expand 합니다. 이 때, I 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐의 맨 왼쪽에 있는 J 를 Dequeue and Expand 합니다. 이 때, J 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐의 맨 왼쪽에 있는 K 를 Dequeue and Expand 합니다. 이 때, K 는 자식이 없으므로 큐에 넣을 것이 없습니다.\n  큐가 비었습니다. 모든 노드를 탐색했다는 뜻이죠!\n ","date":"2021-03-26T00:00:00Z","image":"https://ssabum.github.io/content/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%A1%A0/algorithm_hue59cc96f39be3bdd739f8972409a29e2_15547_120x120_fill_box_smart1_2.png","permalink":"https://ssabum.github.io/content/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%A1%A0/","title":"알고리즘 기초이론"}]