<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on Ssabum&#39;s Devlog</title>
    <link>https://ssabum.github.io/tags/python/</link>
    <description>Recent content in python on Ssabum&#39;s Devlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ssabum.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>백준 1463번 1로 만들기</title>
      <link>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1463%EB%B2%88-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1463%EB%B2%88-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid>
      <description>1463번 1로 만들기 문제 보러가기
🅰 설계   문제에서 주어진 아래의 조건에 맞추어 코드를 구현하고 카운트의 최솟값을 구하는 알고리즘을 실행시켰지만 답이 나오지 않았다&amp;hellip;
  x가 3으로 나누어 떨어지면, 3으로 나눈다.
  x가 2로 나누어 떨어지면, 2로 나눈다.
  1을 뺀다.
    다음으로 연필로 써내려가면서 규칙이 있나 찾아보았다. 개인적으로 싫어하는 방법이지만 풀 방법이 생각나지 않아 도전해 보았다&amp;hellip;
역시, 규칙은 보이지 않았다&amp;hellip;
  ✔ 정답 코드 구글링 N = int(input()) dp_list = [0,0,1,1] # 0 ,1, 2, 3 의 최소 수 미리 저장 for i in range(4, N + 1) : # 먼저 1을 뺏을 경우 나오는 경우의 수 저장 dp_list.</description>
    </item>
    
    <item>
      <title>백준 1541번 잃어버린 괄호</title>
      <link>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1541%EB%B2%88-%EC%9E%83%EC%96%B4%EB%B2%84%EB%A6%B0-%EA%B4%84%ED%98%B8/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1541%EB%B2%88-%EC%9E%83%EC%96%B4%EB%B2%84%EB%A6%B0-%EA%B4%84%ED%98%B8/</guid>
      <description>1541번 잃어버린 괄호 문제 보러가기
🅰 코드 # &amp;#39;-&amp;#39;부호로 나눠진 문자열 저장 arr = input().split(&amp;#39;-&amp;#39;) # 결과 변수 생성 result = 0 # 처음 &amp;#39;-&amp;#39;부호가 나오는 부분까지 더하기 for i in arr[0].split(&amp;#39;+&amp;#39;): result += int(i) # 그 뒤엔 다 빼주는데 &amp;#39;+&amp;#39;부호로 묶인 것도 나눠서 빼기 → -(a+b) = -a-b for i in arr[1:]: for j in i.split(&amp;#39;+&amp;#39;): result -= int(j) print(result) ✅ 후기  문제에 주어진 문자열에서 차례로 연산을 하기만 하면 되는 비교적 쉬운 문제였다고 생각했지만 중간에 한번 함정이 있어서 고민이 필요했다&amp;hellip; 문제에서 요구하는 가장 최소의 값이 나오긴 위해서는 -부호 뒤에 오는 숫자들의 값이 커야 했으며 이를 표현하기 위해 -부호 뒤의 문자열에서 +부호로 나누어 각각을 빼주는 작업을 진행하였다.</description>
    </item>
    
    <item>
      <title>백준 1620번 나는야 포켓몬 마스터 이다솜</title>
      <link>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1620%EB%B2%88-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1620%EB%B2%88-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C/</guid>
      <description>1620번 나는야 포켓몬 마스터 이다솜 문제 보러가기
🅰 코드 # 데이터 입력 N, M = map(int,input().split()) # 포켓몬을 &amp;#39;이름:번호&amp;#39;로 딕셔너리 생성 arr = [0] dict = {} for num in range(1,N+1): monster = input().strip() arr.append(monster) dict[monster] = num # 주어진 문제에 대해 숫자인지, 문자인지 판별 후 검색 for _ in range(M): q = input().strip() if q.isalpha() : print(dict[q]) elif q.isdigit() : print(arr[int(q)]) ✅ 후기  일단 문제를 읽기 싫었다&amp;hellip;포켓몬컨셉인건 알겠는데 사설이 너무 길다&amp;hellip; 나중에 기회가 된다면 내가 직접 깔끔하고 섹시한 문제를 만들어 올릴 것이다.</description>
    </item>
    
    <item>
      <title>백준 1003번 피보나치 함수</title>
      <link>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1003%EB%B2%88-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1003%EB%B2%88-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98/</guid>
      <description>1003번_피보나치 함수 문제 보러가기
🅰 설계 t = int(input()) for i in range(t): n = int(input()) # fib(0), fib(1), tmp 설정 zero, one, tmp = 1, 0, 0 # 피보나치 수행 for _ in range(n): tmp = one one = one + zero zero = tmp # 출력 print(zero, one) ✅ 후기 // 풀이과정
 처음 문제를 읽고 어떻게 해야할지 풀이가 떠오르지 않아 꽤나 고생했다.😥 하지만 5까지의 경우의 수를 직접 표로 그려보니 간단한 문제임을 알 수 있었다.</description>
    </item>
    
    <item>
      <title>백준 1012번 유기농 배추</title>
      <link>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1012%EB%B2%88-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1012%EB%B2%88-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/</guid>
      <description>1012번_유기농 배추 문제 보러가기
🅰 설계 import sys sys.stdin = open(&amp;#34;input.txt&amp;#34;) T = int(input()) for tc in range(1, T+1): # m: 가로길이, n: 세로길이, k: 배추개수 m, n, k = map(int, input().split()) # 입력된 데이터에 맞춰 밭 만들어 주기 field = list(list(0 for i in range(m)) for _ in range(n)) # 밭에 배추 심기 for i in range(k): x, y = map(int, input().split()) field[y][x] = 1 # 지렁이 검사 cnt = 0 # 이후 접근을 어떻게 해야할지.</description>
    </item>
    
    <item>
      <title>백준 1074번 Z</title>
      <link>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1074%EB%B2%88-z/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1074%EB%B2%88-z/</guid>
      <description>1074번_Z 문제 보러가기
🅰 설계 import sys result = 0 def z(n, x, y): global result # 기본이 되는 탈출 조건 생성 if x == r and y == c: print(int(result)) exit(0) if n == 1: result += 1 return # 처음에 시간초과 떠서 경우의 수도 합쳐 주었다. # 하지만 나중에 알고보니 할 필요 없었다... if not (x &amp;lt;= r &amp;lt; x + n and y &amp;lt;= c &amp;lt; y + n): result += n * n return # 재귀함수 z(n / 2, x, y) z(n / 2, x, y + n / 2) z(n / 2, x + n / 2, y) z(n / 2, x + n / 2, y + n / 2) # 시간초과 안나기 위해 sys.</description>
    </item>
    
    <item>
      <title>백준 1107번 리모컨</title>
      <link>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1107%EB%B2%88-%EB%A6%AC%EB%AA%A8%EC%BB%A8/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1107%EB%B2%88-%EB%A6%AC%EB%AA%A8%EC%BB%A8/</guid>
      <description>1107번_리모컨 문제 보러가기
🅰 코드 # N: 목표로 하는 채널번호(0~500000), M: 고장난 버튼의 개수(0~10) N = int(input()) M = int(input()) # button: 숫자 버튼 / 고장난 버튼이 있으면 빼준다 button = {i for i in range(10)} if M != 0: button -= set(map(int, input().split())) # 100번에서 N번으로 +, - 버튼만 쓴 경우 cnt = abs(100 - N) # 50만 채널인데 최악의 경우를 고려할 때 # 작은수에서 +만 사용(50만)에 큰수에서 -만 사용(50만)을 더하면 100만 가지의 경우의 수가 발생 for i in range(1000000): flag = True for j in str(i): if int(j) not in button: flag = False break if flag: # button으로 접근 할 수 있는 수에다가 목표 채널의 차이(+, - 으로 이동)를 더한 값 cnt = min(cnt, len(str(i)) + abs(N-i)) print(cnt) 🅰 &amp;amp;연산자 사용 !</description>
    </item>
    
    <item>
      <title>백준 1260번 DFS와 BFS</title>
      <link>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1260%EB%B2%88-dfs%EC%99%80-bfs/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1260%EB%B2%88-dfs%EC%99%80-bfs/</guid>
      <description>1260번_DFS와 BFS 문제 보러가기
🅰 코드 N,M,V=map(int,input().split()) matrix=[[0]*(N+1) for i in range(N+1)] for i in range(M): a,b = map(int,input().split()) matrix[a][b]=matrix[b][a]=1 visit_list=[0]*(N+1) def dfs(V): visit_list[V]=1 print(V, end=&amp;#39; &amp;#39;) for i in range(1,N+1): if(visit_list[i]==0 and matrix[V][i]==1): dfs(i) def bfs(V): queue=[V] visit_list[V]=0 while queue: V=queue.pop(0) print(V, end=&amp;#39; &amp;#39;) for i in range(1, N+1): if(visit_list[i]==1 and matrix[V][i]==1): queue.append(i) visit_list[i]=0 dfs(V) print() bfs(V) ✅ 후기  문제 자체는 SSAFY교육에도 진행되었던 DFS, BFS의 가장 기본인 코드를 구현하는 것이었다.</description>
    </item>
    
    <item>
      <title>백준 1389번 케빈 베이컨의 6단계 법칙</title>
      <link>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1389%EB%B2%88-%EC%BC%80%EB%B9%88-%EB%B2%A0%EC%9D%B4%EC%BB%A8%EC%9D%98-6%EB%8B%A8%EA%B3%84-%EB%B2%95%EC%B9%99/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EB%B0%B1%EC%A4%80-1389%EB%B2%88-%EC%BC%80%EB%B9%88-%EB%B2%A0%EC%9D%B4%EC%BB%A8%EC%9D%98-6%EB%8B%A8%EA%B3%84-%EB%B2%95%EC%B9%99/</guid>
      <description>1389번_케빈 베이컨의 6단계 법칙 문제 보러가기
🅰 코드 from collections import deque def bfs(num, n): # 기본 base setting bacon = [0] * (n + 1) visited = [num] queue = deque() queue.append(num) while queue: # queue에서 popleft사용 k = queue.popleft() for i in relation[k]: if i not in visited: bacon[i] = bacon[k] + 1 visited.append(i) queue.append(i) return sum(bacon) # n: 유저수(2~100), m: 관계수(1~5000) n, m = map(int, input().split()) # 관계 dict생성 후 입력 relation = {i: [] for i in range(1, n + 1)} for i in range(m): a, b = map(int, input().</description>
    </item>
    
    <item>
      <title>CSS기초</title>
      <link>https://ssabum.github.io/p/css%EA%B8%B0%EC%B4%88/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/css%EA%B8%B0%EC%B4%88/</guid>
      <description>CSS  스타일, 레이아웃 등을 통해 HTML이 사용자에게 어떻게 표시 되는지를 지정하는 언어
사용자에게 문서(HTML)를 표시하는 방법을 지정하는 언어
 CSS 구문  구문은 선택자와 함께 열린다. 스타일을 지정할 html 요소를 선택. 다음 중괄호가 있는데 이 안에는 속성과 값 쌍 형태를 가지는 하나 또는 그 이상의 선언(declaration)이 있다. 각 쌍은 우리가 선택한 요소의 속성을 지정하고 속성에 부여할 값을 지정한다.  선언문
 속성 (Property)  사람이 읽을 수 있는 식별자로, 어떤 (글꼴, 너비, 배경색 등) 스타일 기능을 변경할지 나타냅니다.</description>
    </item>
    
    <item>
      <title>CSS기초 레이아웃</title>
      <link>https://ssabum.github.io/p/css%EA%B8%B0%EC%B4%88-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/css%EA%B8%B0%EC%B4%88-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/</guid>
      <description>CSS Layout  웹페이지에 포함되는 요소들을 어떻게 취합하고 그것들이 어느 위치에 놓일 것인지를 제어한다.
 float  한 요소(element)가 정상 흐름(normal flow)으로부터 빠져 텍스트 및 인라인(inline) 요소가 그 주위를 감싸 자기 컨테이너의 좌,우측을 따라 배치되어야 함을 지정한다.
 clearfix
  float 요소와 다른 텍스트가아닌 block 요소간의 레이아웃 깨짐을 막기 위해 다음과 같이 작성한다.
/* float 속성을 적용한 요소의 부모요소에 적용한다. */ /* 부모 태그 다음에 가상 요소(::after)로 내용이 빈(content:&amp;#34;&amp;#34;) 블럭(display: block;)을 만들고 */ /* 이 가상요소는 float left,right(both)를 초기화 한다는 뜻 */ .</description>
    </item>
    
    <item>
      <title>Django 기본</title>
      <link>https://ssabum.github.io/p/django-%EA%B8%B0%EB%B3%B8/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/django-%EA%B8%B0%EB%B3%B8/</guid>
      <description>Django wep programming  파이썬으로 만들어진 무료 오픈소스 웹 애플리케이션 프레임워크
즉, 쉽고 빠르게 웹사이트를 개발할 수 있도록 돕는 구성요소로 이루어진 웹 프레임워크
여기서 프레임워크란, 애플리케이션 개발에 바탕이 되는 템플릿과 같은 역할을 하는 클래스들과 인터페이스의 집합
 기본 생성 파일  mysite: 프로젝트를 담는 공간 manage.py: 프로젝트와 다양한 방법으로 상호작용 하는 커맨드라인의 유틸리티 init.py: 파이썬으로 하여금 이 디렉토리를 패키지처럼 다루라고 알려주는 용도의 빈 파일 setting.py: 현재 프로젝트의 환경 및 구성을 저장 urls.</description>
    </item>
    
    <item>
      <title>HTML기초</title>
      <link>https://ssabum.github.io/p/html%EA%B8%B0%EC%B4%88/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/html%EA%B8%B0%EC%B4%88/</guid>
      <description>HTML  &amp;ldquo;웹 컨텐츠의 의미와 구조를 정의할 때 사용하는 언어&amp;rdquo;
 HTML 기초 Hyper
 텍스트 등의 정보가 동일 선상에 있는 것이 아니라 다중으로 연결되어 있는 상태  Hyper Text
 참조(하이퍼링크)를 통해 사용자가 한 문서에서 다른 문서로 즉시 접근 할 수 잇는 텍스트 하이퍼 텍스트가 쓰인 기술등 중 가장 중요한 2가지 (http, html)  Markup Language
 특정 텍스트에 역할을 부여하는, 따라서 &amp;ldquo;마크업을 한다&amp;rdquo; 라고 하는 건 제목이 제목이라하고 본문이 본문이라고 마킹을 하는 것 ex) h1 tag는 단순히 글자가 커지는 것이 아니라 의미론적으로 그 페이지에서 가장 핵심 주제를 의미하는 것  HTML 기본 구조 DOM</description>
    </item>
    
    <item>
      <title>OOP</title>
      <link>https://ssabum.github.io/p/oop/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/oop/</guid>
      <description>&lt;p&gt;&lt;code&gt;Object-Oriented Programming&lt;/code&gt;의 약자로 &lt;code&gt;객체지향프로그래밍&lt;/code&gt;이다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>알고리즘 기초이론</title>
      <link>https://ssabum.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%A1%A0/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ssabum.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%88%EC%9D%B4%EB%A1%A0/</guid>
      <description>&lt;p&gt;Algorithm기본 이론에 대해 알아보자&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
